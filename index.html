<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">

  <title>OKP: Python kevytspesifikaatio</title>
  <meta http-equiv="content-type" content=
  "text/html; charset=utf-8">
  <link rel="stylesheet" href="style.css" type="text/css" media=
  "screen"><!-- Syntaxhiglight -->

  <script type="text/javascript" src="script/sh_main.js">
</script>
  <script type="text/javascript" src="script/sh_python.js">
</script>
  <link type="text/css" rel="stylesheet" href=
  "script/sh_typical.css">
</head>

<body onload="sh_highlightDocument();">
  <h1><img src="python_logo.png" alt="Python" id="logo" name=
  "logo"> kevytspesifikaatio</h1>

  <p>Kurssi: <a href=
  "http://www.cs.helsinki.fi/u/wikla/OKP/K11/">581362
  Ohjelmointikielten periaatteet, kevät 2011 (4 op)</a></p>

  <h2>Työryhmä</h2>

  <ul>
    <li>Juhani Åhman &lt;juhani.ahman@cs.helsinki.fi&gt;</li>

    <li>Juha Louhiranta &lt;juha.louhiranta@helsinki.fi&gt;</li>

    <li>Matti Nauha &lt;mtnauha@cs.helsinki.fi&gt;</li>

    <li>Timo Lehto &lt;timo.lehto@cs.helsinki.fi&gt;</li>
  </ul>

  <h2>Sisältö</h2>

  <ol class="toc">
    <li><a href="#chapter-1">Kielen taustaa ja
    miniesimerkki</a></li>

    <li><a href="#chapter-2">Alkiorakenne – millaisista palikoista
    ohjelmat rakennetaan</a></li>

    <li><a href="#chapter-3">Tunnusten näkyvyysalueet</a></li>

    <li><a href="#chapter-4">Kontrollin ja/tai laskennan
    ohjaus</a></li>

    <li><a href="#chapter-5">Perustietotyypit</a></li>

    <li><a href="#chapter-6">Laskennan kapselointi</a></li>

    <li><a href="#chapter-7">Datan kapselointi</a></li>

    <li><a href="#chapter-8">Yhteenveto</a></li>

    <li><a href="#lahteet">Lähteet</a></li>
  </ol>

  <h2 id="chapter-1">1. Kielen taustaa ja miniesimerkki</h2>

  <ol class="sub-toc">
    <li><span>1.1.</span><a href="#chapter-1-historia">Historia</a></li>

    <li><span>1.2.</span><a href="#chapter-1-perustietoa">Python
    perustietoa</a></li>

    <li><span>1.3.</span><a href="#chapter-1-kayttokohteet">Käyttökohteet</a></li>

    <li><span>1.4.</span><a href="#chapter-1-fibonacci">Fibonacci esimerkki</a></li>
  </ol>

  <h3 id="chapter-1-historia">1.1. Historia</h3>

  <p>Pythonin historia alkaa 1980-luvulta. Ensimmäinen versio
  ohjelmointikielestä kehitettiin 80-luvun loppupuolella Guido van
  Rossumin toimesta. Python kehitettiin ABC kielen seuraajaksi,
  joka kykenee mm. poikkeusten käsittelyyn ja yhteistyöhön Amoeba
  -käyttöjärjestelmän kanssa. Kielen alun perin kehittänyt van
  Rossum on edelleen aktiivisesti mukana kielen kehittämisessä</p>

  <p>Python 2.0, julkaistiin 16. lokakuuta 2000. Toinen versio
  sisälsi useita uusia ominaisuuksia, mukaan lukien täydellisen
  roskienkeruumekanismin ja Unicode-tuen. Muutos tapahtui myös
  kielen kehitysprosessissa. Python -yhteisölle annettiin vapaammat
  kädet osallistua mukaan kielen kehitykseen.</p>

  <p>Joulukuussa 2008 ilmestyi 3.0, jolla haluttiin korjata
  havaittuja ongelmia kielessä. Kielestä haluttiin poistaa
  duplikaatteja ominaisuuksia poistamalla vanhat tavat tehdä
  asioita. 3.x ei ole taaksepäin yhteensopiva versioiden 2.x ja
  vanhempien kanssa. Vanhoille versioille kirjoitetut ohjelmat
  eivät toimi suoraan versiossa 3.0. Siirtymän helpottamiseksi on
  toteutettu käännösohjelma (<code>2to3</code>), joka kääntää
  automaattisesti osan koodista kielen uudempaan versioon. Lisäksi
  useita kolmosversion keskeisiä ominaisuuksia on toteutettu
  rinnakkain kehitettyyn 2.6 versioon, mikä mahdollistaa niiden
  hyödyntämisen ilman uudempaan syntaksiin siirtymistä. [<a href=
  "#ref-history-of-python">3</a>]</p>

  <h3 id="chapter-1-perustietoa">1.2. Python perustietoa</h3>

  <ul>
    <li>Keskeinen suunnittelufilosofia: selkeä, luettava
    syntaksi</li>

    <li>Tulkattava</li>

    <li>Oliosuuntautunut ohjelmointikieli</li>

    <li>Korkean tason dynaamiset datatyypit</li>

    <li>Kattavat standardikirjastot ja saatavilla paljon kolmansien
    osapuolien moduuleja eri tarkoituksiin</li>

    <li>Poikkeuksiin <i>(exception)</i> pohjautuva virheiden
    hallinta</li>

    <li>Tukee useita ohjelmointiparadigmoja <i>(esim.
    oliopohjainen, proseduraalinen, funktionaalinen)</i></li>

    <li>Toimii useilla eri alustoilla, esim.

      <ul>
        <li>Windows</li>

        <li>Mac</li>

        <li>Linux</li>

        <li>Amiga</li>

        <li>Nokia series 60</li>
      </ul>
    </li>

    <li>Avoin lähdekoodi, vapaasti käytettävissä ja jaettavissa
    (myös kaupalliseen käyttöön)</li>

    <li>Upotettavissa sovelluksiin skriptausrajapintana <i>(esim.
    Blender)</i></li>

    <li>Käytössä myös muun muassa <a href=
    "http://www.djangoproject.com/">Django</a> -frameworkissa.</li>

    <li>Python nimi tulee tv-sarjasta <i>Monty Python's Flying
    Circus</i>.</li>
  </ul>

  <p>Pythonista on tällä hetkellä olemassa kaksi vakaata haaraa.
  2.x -haara saa tällä hetkellä pelkkiä virheitä korjaavia
  päivityksiä. Uudet ominaisuudet kehitetään vain 3.x -haaralle.
  Suurempi osa kolmansien osapuolien ohjelmistoista käyttää vielä
  Pythonin 2.x -versiota.</p>

  <p>Yleisin Pythonin toteutus on CPython, joka on kirjoitettu
  C-kielellä. CPython kääntää Python ohjelmat. Se kääntää Python
  ohjelmat tavukoodiksi, joka suoritetaan virtuaalikoneessa.
  CPython on saatavilla useille eri käyttöjärjestelmille ja sen
  mukana tulee laaja peruskirjasto.</p>

  <p>Muita Python toteutuksia on esimerkiksi <a href=
  "http://www.jython.org/">Jython</a> (JVM), <a href=
  "http://ironpython.net/">IronPython</a> (.NET) ja <a href=
  "http://pypy.org/">PyPy</a> (Python).</p>

  <h3 id="chapter-1-kayttokohteet">1.3. Käyttökohteet</h3>

  <p>Yksi suosittu tapa hyödyntää Pythonia on sen käyttäminen
  skriptikielenä erilaisissa sovelluksissa. Pythonia käyttävät
  skriptikielenä esimerkiksi 3d-mallinnusohjelmistot Maya ja
  Blender, kuvankäsittelyohjelma GIMP ja se on toinen valittavissa
  oleva skriptikieli Google Docsissa</p>

  <p>Erilaisten kirjastojen <i>(NumPy, SciPy, Matplotlib, ...)</i>
  avulla Pythonia voidaan käyttää tehokkaasti tieteelliseen
  laskentaan.</p>

  <p>Monissa käyttöjärjestelmissä Python kuuluu
  peruskomponentteihin. Python löytyy muun muassa useimmista Linux
  distribuutioista, OpenBSD:stä, ja Mac OS X:stä.</p>

  <h3 id="chapter-1-fibonacci">1.4. Fibonacci esimerkki</h3>

  <p>Seuraavassa esimerkki ohjelmasta, joka lukee yhden
  syöttöluvun, laskee ensimmäisen Fibonaccin luvun, joka on
  syöttölukua suurempi ja lopuksi tulostaa kyseisen Fibonaccin
  luvun.</p>
  <pre class="sh_python">
import sys

def fib(n):
    """Palauttaa ensimmäisen Fibonaccin luvun, joka on syöttölukua suurempi."""
    a, b = 0, 1
    while b &lt;= n:
        a, b = b, a+b
    return b

if __name__ == "__main__": # Pääohjelma
    s = input("Anna fibonacci syöttöluku: ") # Lue syöte käyttäjältä

    # input palauttaa aina stringin, mutta haluamme kokonaisluvun
    try:
        # Yritä muuttaa syöte kokonaislukutyypiksi
        n = int(s)
    except ValueError:
        # Tyypin muutos epäonnistui, poistu ohjelmasta virheviestillä
        sys.exit("Antamasi syöte ei ollut kokonaisluku!")

    print(fib(n))
</pre>

  <p>Ensimmäisen rivin <code>import sys</code> lause importtaa eli
  tuo fibonacci-moduulin sys-moduulin käytettäväksi. sys-moduulin
  exit-metodia käytetään ohjelman loppupuolella päättämään ohjelman
  suoritus sopivalla virheviestillä, jos käyttäjän antama syöte ei
  ollut kokonaisluku.</p>

  <p>Varsinainen Fibonacci luvun laskeminen tapahtuu
  fib-funktiossa. fib-funktio asettaa ensiksi muuttujille a ja b
  Fibonaccin lukujonon alkuarvot <code>a = 0</code> ja <code>b =
  1</code>. Lukujonon lukuja lasketaan while-silmukassa, kunnes
  viimeisin laskettu Fibonaccin luku <code>b = a+b</code> on
  syöttölukua suurempi. Lopuksi palautamme halutun luvun.</p>

  <p>Koska Python ohjelmissa ei ole varsinaista
  "pääohjelmafunktiota", niin se yleensä merkitään näkyviin
  <code>if __name__ == "__main__":</code> lauseella. Tämä suorittaa
  pääohjelma-alueen vain kun moduuli suoritetaan pääohjelmana eikä
  importattuna jostain toisesta moduulista.</p>

  <p>Käyttäjän syöte luetaan input-funktiolla. fib-funktiota varten
  halutaan kokonaislukusyöte. Syötteen tyyppi on riippuvainen
  käyttäjästä, joten se muutetaan kokonaisluvuksi ennen
  fib-funktion kutsua <code>int(x)</code>-kutsulla.
  Kokonaislukumuutos voi kuitenkin epäonnistua, jolloin
  <code>int(x)</code> nostaa <code>ValueError</code> poikkeuksen.
  Jotta käyttäjälle saadaan annettua sopiva virheviesti, niin
  käsittelemme poikkeuksen try-except-rakenteen avulla. Pääohjelman
  lopuksi kutsumme fib-funktiota syötteellä ja tulostamme sen
  palautusarvon.</p>

  <h2 id="chapter-2">2. Alkiorakenne – millaisista palikoista
  ohjelmat rakennetaan</h2>

  <ol class="sub-toc">
    <li><span>2.1.</span><a href="#chapter-2-tunnukset">Tunnukset</a></li>

    <li><span>2.2.</span><a href="#chapter-2-varatut-sanat">Varatut sanat,
    avainsanat</a></li>

    <li><span>2.3.</span><a href=
    "#chapter-2-literaalivakiot">Literaalivakiot</a></li>

    <li><span>2.4.</span><a href="#chapter-2-erottimet-yms">Erottimet, sisennykset,
    rivinvaihdot</a></li>

    <li><span>2.5.</span><a href="#chapter-2-edut-ja-haitat">Arvio kieleen
    valittujen ratkaisujen eduista ja haitoista</a></li>
  </ol>

  <h3 id="chapter-2-tunnukset">2.1. Tunnukset</h3>

  <p>Python 3:ssa tunnukset voidaan nimetä käyttäen merkkejä a-z,
  A-Z, 0-9 ja _. Tunnus ei kuitenkaan voi alkaa numerolla. Pienet
  ja iso kirjaimet tulkitaan eri kirjaimiksi. Tunnukset voivat olla
  rajoittamattoman pituisia. Lisäksi Python 3 tukee suurta joukkoa
  ASCII-järjestelmän ulkopuolisia unicode-merkkejä. Tarkempi
  listaus tuetuista merkeistä löytyy osoitteesta: <a href=
  "http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html">http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html</a>.
  Merkit on jaoteltu kahteen osaan: ID_Start ja ID_Continue,
  excluding ID_Start. Näiden merkkijoukkojen yhdiste sisältää
  kaikki unicode-merkit joita voi esiintyä python-tunnuksen
  nimessä, siten että tunnuksen nimi voi alkaa vain ensimmäisen
  joukon merkillä. <a href="#ref-tunnukset-py3-spec">[2]</a></p>

  <p>Seuraavassa lyhyt esimerkki joka demonstroi erikoisempien
  merkkien käyttöä Python 3 ohjelmassa:</p>
  <pre class="sh_python">
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

def python_3_tukee_unicodemerkkejä_varsin_laajasti(ភាសាខ្មែរ="khemrin kieli khmeriksi"):
    print("Hei vaan ja hellurei!", ភាសាខ្មែរ)

    epävalidia_python_koodia='kuitenkin_esim_€_merkki_ei_ole_sallittu = "epic fai"'
    try:
        exec(epävalidia_python_koodia)
    except SyntaxError as se:
        print("€-merkki ei ollut sallittu muuttujan nimessä :'(", se)

    validia_python_koodia = epävalidia_python_koodia.replace("€", "e")
    exec(validia_python_koodia)
    print("Hyvin pyyhkii. No problemo, kun €-merkit vaihdettiin e-kirjaimiksi")

if __name__ == "__main__":
    python_3_tukee_unicodemerkkejä_varsin_laajasti()

</pre>

  <p>Yllä oleva python ohjelma tulostaa konsoliin tekstin:</p>
  <pre>
Hei vaan ja hellurei! khmerin kieli khmeriksi
€-merkki ei ollut sallittu muuttujan nimessä :'( invalid character in identifier (&lt;string&gt;, line 1)
Hyvin pyyhkii. No problemo, kun €-merkit vaihdettiin e-kirjaimiksi

</pre>

  <p><a href="esimerkit/unicode_sample.py">Lataa esimerkki
  tästä</a></p>

  <h3 id="chapter-2-varatut-sanat">2.2. Varatut sanat</h3>

  <p>Seuraavassa listattuna (Pyton 3.0.1:n mukainen, tässä on
  pieniä eroavaisuuksia 2.x -sarjan kanssa) varatut sanat <a href=
  "#ref-varatut-sanat-py3-spec">[1]</a> sen tarkemmin niitä
  esittelemättä.</p>
  <pre>
False      class      finally    is         return
None       continue   for        lambda     try
True       def        from       nonlocal   while
and        del        global     not        with
as         elif       if         or         yield
assert     else       import     pass
break      except     in         raise


</pre>

  <h3 id="chapter-2-literaalivakiot">2.3. Literaalivakiot</h3>

  <p>Python tukee seuraavia literaalivakioita [<a href=
  "#ref-literaalivakiot">4</a>]:</p>

  <ul>
    <li>merkkijonot,<br>
    <code>"hello"</code>, <code>'world'</code>,<br>
    <code>"""Olen<br>
    monella<br>
    rivillä"""</code></li>

    <li>kokonaisluvut,<br>
    <code>7</code>, <code>79228162514264337593543950336</code>,
    <code>0b100110111</code>, <code>0xdeadbeef</code></li>

    <li>liukuluvut,<br>
    <code>3.14</code>, <code>10.</code>, <code>.001</code>,
    <code>1e100</code>, <code>3.14e-10</code>,
    <code>0e0</code></li>

    <li>imaginääriluvut<br>
    <code>3.14j</code>, <code>10.j</code>, <code>10j</code>,
    <code>.001j</code>, <code>1e100j</code>,
    <code>3.14e-10j</code></li>
  </ul>

  <p>Numeerisista literaaleista on hyvä mainita vielä se, että ne
  eivät sisällä etumerkkiä. Esimerkiksi merkintä <code>-1</code>
  koostuu yksipaikkaisesta operaatiosta <code>-</code> ja
  literaalista <code>1</code>.</p>

  <h3 id="chapter-2-erottimet-yms">2.4. Erottimet, sisennykset,
  rivinvaihdot</h3>

  <p>Pythonissa käytetään sisennyksiä rajaamaan lohkoja. Sisennystä
  kasvatetaan tiettyjen lausekkeiden jälkeen ja vastaavasti
  sisennystä pienennetään lohkon päättymisen merkiksi. Sekä
  tabulaattorit että välilyönnit kelpaavat sisennysmerkeiksi
  Pythonissa.</p>

  <p>Sisennyksen määrällä ei ole väliä, sisennys voi olla yhden
  tabulaattorin tai vaikkapa kuuden välilyönnin pituinen
  <i>(<b>huom!</b> tabulaattorin ja välilyöntien sekaisin
  käyttäminen ei ole sallittua Pythonissa)</i>. Ainoastaan
  suhteellisella sisennyksen määrällä on väliä sisäkkäisissä
  lohkoissa.</p>

  <p>Lauseet erotellaan toisistaan rivinvaihdoilla. Useita lauseita
  voidaan kirjoittaa samalle riville käyttämällä puolipistettä.
  Kontrollirakenteissa totuusarvolausekkeita seuraa aina
  kaksoispiste ja lausekkeessa ei ole pakko käyttää sulkuja.</p>

  <p>Alla olevissa esimerkeissä kaikki kolme if-rakennetta tekevät
  saman asian <i>(tulostavat sanat "spam" ja "ham")</i>:</p>
  <pre class="sh_python">
if 1 == 1:
    print("spam")
    print("ham")

</pre>
  <pre class="sh_python">
if 1 == 1:
    print("spam"); print("ham")

</pre>
  <pre class="sh_python">
if 1 == 1: print("spam"); print("ham")

</pre>

  <h3 id="chapter-2-edut-ja-haitat">2.5. Arvio kieleen valittujen
  ratkaisujen eduista ja haitoista</h3>

  <p>Unicode-tuki Python 3:ssa tekee aidosti mahdolliseksi
  ohjelmoinnin ohjelmoijan omalla äidinkielellä. Tämä on varmasti
  monessa mielessä hyvä asia ja sen hyödyntäminen todennäköisesti
  parantaa koodin luettavuutta kehittäjäyhteisössä. Toisaalta tällä
  alalla ei ole ollenkaan tavatonta, että ohjelmaa kehitetään
  ympäri maailmaa ja kehittäjien äidinkielet vaihtelevat suuresti.
  Tällöin on käytettävä jotakin yhteistä kieltä eli siis yleensä
  englantia ja tämä unicode-tuki ei juurikaan auta. Toinen tilanne
  jolloin koodia ei varmaankaan haluta tehdä äidinkielellä on, jos
  tuotetaan avoimen lähdekoodin ratkaisuja. Muutoin saatetaan
  varsin tehokkaasti eliminoida iso osa käyttäjäyhteisön
  potentiaalista jatkokehittää tuotetta. Yleisesti ottaen tuote
  joka on ohjelmoitu vaikkapa suomeksi rajoittaa
  jatkokehitysmahdollisuuksia vaikka alkuperäisen kehitystyön
  kannalta kielivalinnalla olisikin ollut positiivisia vaikutuksia.
  Kustannussyistä jatkokehitys saatettaisiin joissain tilanteissa
  haluta tuottaa jossakin edullisemmassa maassa, mutta tämä ei nyt
  olekaan mahdollista ilman huomattavaa käännöstyötä. Kun lisäksi
  otetaan huomioon, että unicode-tuen sisällyttäminen tunnuksiin
  monimutkaistaa kielen implementaatioiden toteuttamista, niin olen
  kyllä henkilökohtaisesti hieman skeptinen koko ominaisuuden
  järkevyydestä. En kyllä itse ainakaan ikinä ohjelmoisi
  vakavissani mitään millään muulla kielellä kuin englannilla.</p>

  <p>Pythonissa sisennystapa ei ole ohjelmoijan täysin vapaasti
  valittavissa, vaan ohjelmoinnissa pakotetaan käyttämään
  tietynlaista sisennystyyliä. Etu tästä on, että ohjelmoija ei voi
  vahingossa kirjoittaa sekavasti sisennettyä koodia, koska se
  rikkoo ohjelman suorituksen. Virheiden mahdollisuus pienenee, kun
  ohjelma tekee, mitä se näyttääkin tekevän, kun virheellinen
  sisentäminen ei pääse sekoittamaan lukijaa. Python koodin
  luettavuutta parantaa se, että kaikki joutuvat käyttämään
  yhtenäistä sisennystapaa.</p>

  <h2 id="chapter-3">3. Tunnusten näkyvyysalueet</h2>
  <!-- TODO: parempi ryhmittely ja otsikkojen nimet -->

  <ol class="sub-toc">
    <li><span>3.1.</span><a href="#chapter-3-lohkorakenne">Lohkorakenne</a></li>

    <li><span>3.2.</span><a href="#chapter-3-sidonta">Sidonta</a></li>

    <li><span>3.3,</span><a href=
    "#chapter-3-sidonta-esim">Esimerkki tunnusten näkyvyydestä, lohkorakenteista ja
    sidonnasta</a></li>
    
    <li><span>3.4.</span><a href=
    "#chapter-3-sisakkaiset-nimiavaruudet-ja-funktiot">Sisäkkäiset
    nimiavaruudet ja funktiot</a></li>
    
    <li><span>3.5.</span><a href="#chapter-3-1-2-ja-3-luokan-arvo">Ensimmäisen,
    toisen ja kolmannen luokan arvo</a></li>

    <li><span>3.6.</span><a href="#chapter-3-edut-ja-haitat">Arvio kieleen
    valittujen ratkaisujen eduista ja haitoista</a></li>
  </ol>

  <h3 id="chapter-3-lohkorakenne">3.1. Lohkorakenne</h3>

  <p>Pythonissa lohkoksi kutsutaan koodinpätkää, joka suoritetaan
  yhtenä yksikkönä. Seuraavia rakenteita kutsutaan lohkoiksi: [<a href="#ref-nimet-ja_sidonta-py3-spec">6</a>]</p>

  <ul>
    <li>moduuli</li>

    <li>funktion vartalo</li>

    <li>luokan määrittely</li>

    <li>jokainen interaktiivisesti kirjoitettu komento</li>

    <li>skriptitiedosto (annettuna tulkille
    komentoriviparametrina)</li>

    <li>skriptikomento (annettuna tulkille -c komentoriviparametrin
    arvona)</li>

    <li>exec() tai eval() -funktioille merkkijonona annettu
    koodi</li>
  </ul>

  <p>Kuten on jo aiemmin mainittu Python käyttää sisennyksiä
  määrittelemään lohkoja. Sisennys kasvaa tiettyjen ilmaisujen
  jälkeen ja puolestaan pienenee lohkon loppumisen merkiksi.
  Samalla tasolla lohkossa sijaitsevat lauseet kirjoitetaan
  jokainen omalle riville käyttäen samaa sisennystä (tai tietenkin
  vaihtoehtoisesti kirjoittamalla kaikki samalle riville käyttäen
  <code>;</code> -merkkiä erottimena).</p>

  <p>Lohkon määrittely voidaan aloittaa mm. seuraavilla sanoilla:
  <code>if, else, elif, for, while, try, except, finally, class,
  def, with, pass</code>.</p>

  <p>Jos lohkon sisällä määritellään lokaali muuttuja, on tämän
  muuttujan näkyvyysalue (scope) rajoitettu siihen lohkoon. Mikäli
  tunnus määritellään funktion vartalossa, niin näkyy se myös
  funktion vartalon sisäisille lohkoille (elleivät nämä sido
  tunnukselle uutta merkitystä). Moduulitason tunnukset ovat
  globaaleja. Mikäli lohkon sisältä halutaan (eksplisiittisesti)
  viitata lohkon ulkopuolisiin muuttujiin, niin voidaan käyttää
  varattuja sanoja nonlocal ja global. Määreellä nonlocal
  vihjataan, että halutaan viitata näkyvyysaluehierarkiassa
  seuraavaan tasoon jolta tunnus löytyy. Vastaavasti
  global-määreellä siirrytään suoraan etsimään tunnusta globaalilta
  näkyvyysalueelta.</p>

  <h3 id="chapter-3-sidonta">3.2. Sidonta</h3>

  <p>Pythonissa sidonta tapahtuu osittain dynaamisesti ja osittain
  staattisesti. Käytännössä siis näkyvyysalueet (scope)
  määritellään staattisesti, mutta niitä käytetään dynaamisesti.
  Eli toisin sanoen eri näkyvyysalueilla olevat tunnukset
  määritellään, mutta niihin ei liitetä arvoa. Ajonaikaisesti
  voidaan määritellä uusia tunnuksia globaalille tasolle. On
  kuitenkin huomioitava, että Python-funktioille ei voi määritellä
  uusia lokaaleja tunnuksia funktion parsimisen jälkeen (eli
  lokaalit muuttujat määritellään staattisesti). Pythonin
  dokumentaatioissa [<a href="#ref-scopes-and-namespaces">30</a>] myös vihjataan, että staattisuutta tullaan
  jatkossa lisäämään (ja näin ollen dynaamiseen sidontaan
  nojautumista kehotetaan välttämään).</p>

  <h3 id="chapter-3-sidonta-esim">3.3 Esimerkki tunnusten näkyvyydestä, lohkorakenteista ja
  sidonnasta</h3>

  <p>Seuraava esimerkki pyrkii demonstroimaan hieman kaikkea
  tunnusten näkyvyyteen liittyvää. Siinä näytetään miten saadaan
  aikaan ajonaikainen poikkeus sidonnasta ja toisaalta myös
  demonstroidaan muuttujien näkyvyyttä.</p>
  <pre class="sh_python">
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

muuttuja="globaali"
print("moduulitasolla", muuttuja)

def main():
    import sys
    #muuttuja on selvästi edelleen globaalien nimien joukossa
    if 'muuttuja' in globals(): print("muuttuja on määritelty globaalilla tasolla")

    try:
        #FAIL! UnboundLocalError: local variable 'muuttuja' referenced before assignmen!
        print("fail", muuttuja)
    except UnboundLocalError:
        name, msg = sys.exc_info()[:2]

    #Btw. alemmalla lohkotasolla määritellyt muuttujat näkyvät ylemmälle
    print(name.__name__+":", msg)

    #Ja syy on seuraavalla koodirivillä. Näin käy sillä kääntäjä merkitsee seuraavan
    #lauseen takia nimen muuttuja olemaan tyypiltään lokaali viittaus tässä
    #lohkossa. Siten suoritusaikana kun nimeen muuttuja viitataan yllä, sitä
    #etsitäänkin vain lokaalien muuttujien joukosta. Koska tämä lause jossa lokaali
    #nimi muuttuja sidotaan merkkijonoon "lokaali", on ensimmäisen nimeen tehdyn
    #viittauksen jälkeen tässä lohkossa, on muuttuja tässä siis vielä
    #sitomatta.
    muuttuja = "lokaali"
    print("main", muuttuja)

    def fun():
        global muuttuja
        print("funktio", muuttuja)
    fun()

    lam = lambda: print("lambda", muuttuja)
    lam()

    #Seuraava if-rakenne saisi kuitenkin aikaan sen, että kaikkialla main-metodissa
    #tunnus muuttuja viittaisi saman nimiseen moduulitason globaaliin muuttujaan.
    #Tämä ei toki sinänsä liene kovin yllättävää, mutta toimii kuitenkin pienenä
    #demonstraatio siitä, että if-rakenne ei ole lohko. Ei ainakaan Pythonissa :)
    #if True:
    #    global muuttuja
    #    print("globaali", muuttuja)

if __name__ == '__main__':
    main()
    print("moduulitasolla if-lohkossa", muuttuja)
  
</pre>

  <p>Skripti tekee seuraavan tulostuksen (<a href=
  "esimerkit/unbound_excep_esim.py">lataa esimerkki</a>)</p>
  <pre>
moduulitasolla globaali
muuttuja on määritelty globaalilla tasolla
UnboundLocalError: local variable 'muuttuja' referenced before assignment
main lokaali
funktio globaali
lambda lokaali
moduulitasolla if-rakenteessa globaali
  
</pre>

  <h3 id="chapter-3-sisakkaiset-nimiavaruudet-ja-funktiot">
  3.4 Sisäkkäiset nimiavaruudet ja funktiot</h3>

  <p>Python tukee sisäkkäisiä nimiavaruuksia versiosta 2.2 lähtien
  [<a href="#ref-sulkeumat-py22">5</a>]. Sitä ennen nimiavaruuksia
  oli vain kolme: paikallinen nimiavaruus, moduulitason nimiavaruus
  ja sisäänrakennettu nimiavaruus. Vaikka funktion määrittely oli
  mahdollista toisen funktion sisällä, niin sisäkkäinen funktio ei
  voinut viitata oman nimiavaruutensa ulkopuolisiin nimiin.</p>
  <pre class="sh_python">
def eka(p):
    x = "olen ekan x"
    print("--- eka alkaa ---")
    p() # tokan paikalliset eivät näy tänne.
        # funktio p käydään suorittamassa määrittelykohdan ympäristössä
    print(x)
    print("--- eka päättyy ---")

def toka():
    print("--- toka alkaa ---")
    x = "olen tokan x"

    def fpar():
        nonlocal x # muuttuja x viittaa nyt sulkeuman ulkopuoliseen viimeiseksi
                   # sidottuun tunnukseen eli tokan muuttujaan x
        print(x)
        x = "tokan x on muutettu!"

    eka(fpar) # "nimetyn sulkeuman" välitys funktioparametrina
    print(x) # viittaus paikalliseen tunnukseen
    print("--- toka päättyy ---")

if __name__ == "__main__": # Pääohjelma
    toka()
</pre>

  <p>Ohjelma tulostaa:</p>
  <pre>
--- toka alkaa ---
--- eka alkaa ---
olen tokan x
olen ekan x
--- eka päättyy ---
tokan x on muutettu!
--- toka päättyy ---
</pre>

  <p>Python tukee myös anonyymejä funktioita lambda-lausekkeiden
  muodossa. Lambda-lausekkeella voi helposti luoda pieniä
  anonyymejä funktioita. Esimerkiksi funktio <code>lambda: a, b:
  a*b</code> palauttaa kahden argumenttinsa kertolaskun.
  Lambda-lauseke on kuitenkin aina vain yksi lauseke eikä lause,
  joten siihen ei voi sisällyttää esimerkiksi toisto- tai
  ehtolauseita suoraan. Se ei siis vastaa useimpien muiden kielten
  anonyymejä funktioita. Lambda-lausekkeet voivat viitata
  nimiavaruutensa ulkopuolisiin tunnuksiin kuten funktiot:</p>
  <pre class="sh_python">
def tee_kertoja(n):
    return lambda x: x * n

f = tee_kertoja(5)
print(f(3)) # 15
print(f(5)) # 25
</pre>

  <h3 id="chapter-3-1-2-ja-3-luokan-arvo">3.5. Ensimmäisen, toisen ja
  kolmannen luokan arvo</h3>

  <p>Pythonissa yksi tavoitteista on ollut tehdä kaikista
  objekteista ensimmäisen luokan arvoja, eli sellaisia, joita
  voidaan:</p>

  <ul>
    <li>sijoittaa muuttujaan</li>

    <li>välittää parametrina</li>

    <li>palauttaa funktion arvona</li>
  </ul>

  <p>Huomion arvoista on, että Pythonissa myös metodit ovat
  ensimmäisen luokan arvoja. [<a href=
  "#ref-ensimmaisenluokan">7</a>]</p>

  <h3 id="chapter-3-edut-ja-haitat">3.6. Arvio kieleen valittujen
  ratkaisujen eduista ja haitoista</h3>

  <p>Lohkojen pakotettu sisentäminen on hyvä asia, koodin
  luettavuus lisääntyy ja se myös pakottaa kaikki kirjoittamaan
  koodia samalla tavalla eli sisentäen.</p>

  <h2 id="chapter-4">4. Kontrollin ja/tai laskennan ohjaus</h2>

  <p><em>miten perustoiminnallisuudet ilmaistaan</em></p>

  <ol class="sub-toc">
    <li><span>4.1.</span><a href="#chapter-4-valinta">Valinta</a></li>

    <li><span>4.2.</span><a href="#chapter-4-toisto">Toisto eli iteraatio</a></li>

    <li><span>4.3.</span><a href="#chapter-4-rekursio">Rekursio</a></li>

    <li><span>4.4.</span><a href="#chapter-4-esimerkkeja">Havainnollisia
    selostettuja pieniä ohjalmaesimerkkejä</a></li>

    <li><span>4.5.</span><a href="#chapter-4-arvio">Arvio kieleen valittujen
    ratkaisujen eduista ja haitoista</a></li>
  </ol>

  <h3 id="chapter-4-valinta">4.1. Valinta</h3>

  <h4>4.1.1. <code>if</code> -lause</h4>

  <p><code>if</code> -lause koostuu kolmesta eri osasta
  <code>if</code>, <code>elif</code>, <code>else</code>.</p>
  <pre class="sh_python">
x = int(input("Please enter an integer: "))
if x &lt; 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
</pre>

  <p>Edellinen koodi tulostaa esim.:</p>
  <pre>
Please enter an integer: <strong>42</strong>
More
</pre>

  <p><code>elif</code> -osioita voi yhdessä lauseessa olla
  mielivaltainen määrä tai ei yhtään. Myös <code>else</code> -osan
  käyttö on vapaaehtoista. Python ei tue monista muista kielistä
  tuttua switch/case -rakennetta vaan tämä tulee toteuttaa
  if-rakenneella [<a href="#ref-controlflow">8</a>].</p>

  <h3 id="chapter-4-toisto">4.2. Toisto eli iteraatio</h3>

  <p>Myös toistolausekkeilla on Pythonissa else -lause [<a href=
  "#ref-controlflow">8</a>], joka suoritetaan jos <code>for</code>
  -lauseessa lista loppuu tai jos <code>while</code> -lause saa
  arvon <code>False</code>. <code>else</code> -lohkoa ei suoriteta
  jos toistolauseesta poistutaan <code>break</code> -lauseella.</p>

  <h4>4.2.1. <code>for</code> -lause</h4>

  <p>for -lausetta käytetään iterointiin. Lause käyttää hyväkseen
  annetun objektin iteraattoria, jota se käy järjestyksessä läpi
  kunnes viimeinen arvo on saavutettu. Muista kielistä poiketen
  tässä rakenteessa ei voi erikseen määritellä iteraatioaskelta tai
  pysäytysehtoa.</p>
  <pre class="sh_python">
a = ['cat', 'window', 'defenestrate']
for x in a:
    print(x, len(x))
</pre>

  <p>Edellinen koodi tulostaa:</p>
  <pre>
cat 3
window 6
defenestrate 12
</pre>Seuraavassa <code>for</code> -lauseessa puretaan listassa
olevat monikot ja käytetään <code>string</code> -luokasta löytyvää
korvausoperaatiota, joka muuttaa <code>{}</code> -merkkien välistä
löytyvä kohdat halutuiksi.
  <pre class="sh_python">
animals = [ ('Cat', 'Meow'),
            ('Cow', 'Moo'),
            ('Dog', 'Woof')]

for animal, sound in animals:
    print("{0} says {1}!".format(animal, sound))
</pre>

  <p>Edellinen koodi tulostaa:</p>
  <pre>
Cat says Meow!
Cow says Moo!
Dog says Woof!
</pre>

  <p>Haluttaessa toistaa tietty koodi useampaan kertaan voidaan
  käyttää hyväksi esim. <code>range()</code> -funktiota, joka
  tuottaa halutun kokoisen kokonaislukuiteraattorin.</p>
  <pre class="sh_python">
for i in range(5):
    print(i)
</pre>

  <p>Edellinen koodi tulostaa:</p>
  <pre>
0
1
2
3
4
</pre>

  <h4>4.2.2. <code>while</code> -lause</h4>

  <p><code>while</code> -lausetta käytetään suorittamaan lauseessa
  olevaa koodia niin pitkään kun jatkamisehto pysyy totena
  [<a href="#ref-compoundstatement">9</a>]. Pythonissa ei ole
  erillistä loppuehtoista do/while -lausetta. Sama tulos voidaan
  kuitenkin saavuttaa muotoilemalla <code>while</code> -lause
  oikein (esim. <code>while True:</code> ja sisällä tarkistus
  <code>if condition: break</code>)</p>
  <pre class="sh_python">
x = 3
while x &lt; 3:
    print("Loopissa")
    x += 1
else:
    print("Loopin else")
</pre>

  <p>Edellinen koodi tulostaa:</p>
  <pre>
Loopissa
Loopissa
Loopissa
Loopin else
</pre>

  <h4>4.2.3. <code>continue</code> &amp; <code>break</code> -lauseet</h4>

  <p><code>continue</code> -lause hyppää toistorakenteessa suoraan
  toistorakenteen seuraavalle iteraatiokierrokselle. Tätä voidaan
  käyttää siis, kun halutaan ohittaa osa toistorakenteen koodista
  juuri tällä suorituskerralla. <code>break</code> -lause lopettaa
  toistorakenteen suorittamisen ilman ns. pysäytysehdon täyttymistä
  [<a href="#ref-compoundstatement">9</a>].</p>

  <h3 id="chapter-4-rekursio">4.3. Rekursio</h3>

  <p>Rekursiivisissa ohjelmarutiineissa idea on sama kuin
  matemaattisesti määritellyissä rekursiivisissa funktioissa, ja
  rekursiivisesti lasketut välitulokset tallennetaan useimmiten
  pinoon. Viimeisellä rekursiokierroksella pinosta kerätään
  vastaukset käänteisessä järjestyksessä. Python tukee rekursiota
  eli sallii funktion kutsua itse itseään.</p>

  <p>Python ei tee eroa normaalin rekursion tai häntärekursion
  välillä [<a href="#ref-tail-recursion">11</a>]. Toisin sanoen se
  ei siis toteuta ominaisuuksia (tunnetaan mm. nimillä <em>tail
  call elimination</em> tai <em>tail call optimization</em>),
  joilla voitaisiin optimoida tilankäyttöä tallettamalla
  häntärekursiossa kutsuttavan funktion aktivaatiotietue kutsujan
  aktivaatiotietueen tilalle pinoon eli muuntamalla rekursio
  vastaamaan tavallista silmukkaa.</p>

  <p>Rekursion syvyys on rajoitettu Pythonissa. Tyypillisessä
  Pythonin implementaatiossa raja-arvo on 1000. Raja estää ikuista
  silmukkaa aiheuttamasta ylivuotoa C:n pinossa ja kaatamasta
  Pythonia [<a href="#ref-library-sys">10</a>]. <code>sys</code>
  -moduulista löytyvät mekanismit, joilla voidaan selvittää
  maksimaalinen rekursiosyvyys
  (<code>sys.getrecursionlimit()</code>) tai asettaa se
  (<code>sys.setrecursionlimit(int)</code>). Rekursiosyvyyden
  oletusarvo riippuu implementaatiosta, kun taas suurin mahdollinen
  arvo on laitteistoriippuvainen.</p>

  <p>Fibonaccin luvun laskeminen rekursiivisesti. Laskee luvun,
  jonka järjestys on n.</p>
  <pre class="sh_python">
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
</pre>

  <h3 id="chapter-4-esimerkkeja">4.4. Havainnollisia selostettuja pieniä
  ohjalmaesimerkkejä</h3>

  <h3 id="chapter-4-arvio">4.5. Arvio kieleen valittujen ratkaisujen
  eduista ja haitoista</h3>

  <p>Muista ohjelmointikielistä tutut <code>do/while</code>- ja
  <code>switch/case</code> -lauseet on jätetty pois ja niitä ei ole
  toteutettu perustellusta syystä. Samat toiminnallisuudet
  pystytään toteuttamaan jo olemassa olevalla syntaksilla.
  Toisaalta esimerkiksi Javasta tuttu
  <code>switch-case-break</code>, jossa myös ehdon täyttävän kohdan
  jälkeen tulevat kohdat suoritetaan ellei <code>switch</code>
  -lauseesta poistuta erikseen <code>break</code> -lauseella,
  saattaa olla hiukan työläämpää toteuttaa Pythonilla.</p>

  <p>Rekursio toimii Pythonissa, mutta esimerkiksi kielen
  alkuperäinen kehittäjä ei henkilökohtaisesti ole sitä mieltä,
  että se olisi jokapäiväinen työkalu vaan pikemminkin teoreettinen
  lähestymistapa matematiikkaan. Häntärekursiosta on olemassa
  jonkinasteisia toteutuksia ja virityksiä, mutta ainakaan
  virallisesti se ei ole Pythonin ominaisuus.</p>

  <h2 id="chapter-5">5. Perustietotyypit</h2>

  <p><em>millaisilla arvoilla tai "datalla" pelataan</em></p>

  <ol class="sub-toc">
    <li><span>5.1.</span><a href="#chapter-5-perustyypit">Perustyypit ja
    arvoalueet</a></li>

    <li><span>5.2.</span><a href="#chapter-5-vahva-heikko-tyypitys">Vahva tyypitys ~
    heikko tyypitys</a></li>

    <li><span>5.3.</span><a href="#chapter-5-stat-dyn-tyypitys">Staattinen tyypitys
    ~ dynaaminen tyypitys</a></li>
  </ol>

  <h3 id="chapter-5-perustyypit">5.1 Perustyypit ja arvoalueet</h3>

  <p>Pythoniin on sisäänrakennettu kattava kokoelma perustyyppejä.
  Pythonissa kaikki on olioita, joten varsinaisia
  primitiivityyppejä ei kuitenkaan ole. Toisaalta ohut oliokääre
  vaikkapa liukulukujen päällä ei ei käytännössä eroa alla olevasta
  implementaatiosta mitenkään. Vastaavasti rajoittamattoman suuret
  kokonaisluvut ovat ääriesimerkki päinvastaisesta tilanteesta.
  Seuraavassa on listattu useimmin käytetyt tyypit. Tämä luku
  perustuu CPythonin tyyppejä käsittelevään dokumentaatioon
  [<a href="#ref-stdtypes">12</a>][<a href=
  "#ref-datamodel">13</a>].</p>

  <p>Numeeriset tyypit:</p>

  <table border="1" summary="Numeeriset tyypit">
    <tr>
      <th>Tyyppi</th>

      <th>Tarkoitus</th>

      <th>Arvoalue</th>

      <th>Esimerkki</th>
    </tr>

    <tr>
      <td><code>None</code></td>

      <td>NULL-arvot</td>

      <td>None</td>

      <td><code>None</code></td>
    </tr>

    <tr>
      <td><code>bool</code></td>

      <td>totuusarvot</td>

      <td>False, True</td>

      <td><code>False</code></td>
    </tr>

    <tr>
      <td><code>int</code></td>

      <td>kokonaisluvut</td>

      <td>−∞ - ∞ (*)</td>

      <td><code>-45353</code></td>
    </tr>

    <tr>
      <td><code>float</code></td>

      <td>kaksoistarkkuuden liukuluvut</td>

      <td>(**)</td>

      <td><code>3.141592653589793</code></td>
    </tr>

    <tr>
      <td><code>complex</code></td>

      <td>kompleksiluvut</td>

      <td>(**)</td>

      <td><code>(9+3j)</code></td>
    </tr>

    <tr>
      <th colspan="4">Standardi kirjaston laajennokset
      numeroille</th>
    </tr>

    <tr>
      <td><code>fractional.Fractional</code></td>

      <td>rationaaliluvut</td>

      <td>ilmeisesti "int/int" (***)</td>

      <td><code>Fraction('14/4')</code><br>
      <code>Fraction(14, 4)</code></td>
    </tr>

    <tr>
      <td><code>decimal.Decimal</code></td>

      <td>tarkat desimaaliluvut</td>

      <td>käyttäjän määrittelee tarkkuuden</td>

      <td><code>Decimal('1.12456765432345')</code></td>
    </tr>
  </table>

  <p>* Periaatteessa arvoalue on rajoittamaton. Käytännössä
  käytettävissä oleva (virtuaali)muisti määrä arvoalueen.</p>

  <p>** Arvoalue riippuu alla olevasta
  toteutuksesta/laitteistosta.</p>

  <p>*** Fractional on abstraktin luokan
  <code>numbers.Rational</code> aliluokka ja ilmeisesti toteutettu
  kahdella kokonaisluvulla (ja siten tarjoaa "rajattoman"
  tarkkuuden).</p>

  <p>Jonotyypit:</p>

  <table border="1" summary="Jonotyypit">
    <tr>
      <th>Tyyppi</th>

      <th>Tarkoitus</th>

      <th>Esimerkki</th>
    </tr>

    <tr>
      <td><code>str</code></td>

      <td>Unicode-merkkijonot (****)</td>

      <td><code>'xyzzy'</code>, <code>"Hello, 世界"</code></td>
    </tr>

    <tr>
      <td><code>bytes</code></td>

      <td>immutaabelit tavumerkkijonot</td>

      <td><code>b'xyzzy'</code></td>
    </tr>

    <tr>
      <td><code>bytearray</code></td>

      <td>tavumerkkijonot</td>

      <td><code>b'xyzzy'</code></td>
    </tr>

    <tr>
      <td><code>list</code></td>

      <td>listat</td>

      <td><code>[1, 2, 3]</code></td>
    </tr>

    <tr>
      <td><code>tuple</code></td>

      <td>monikot</td>

      <td><code>(1, 2, 3)</code></td>
    </tr>
  </table>

  <p>**** Unicode merkkijonot koostuvat 16 tai 32-bittisisitä
  unicode merkeistä. Koko riippuu siitä käytetäänkö
  implementaatiossa/ympäristössä UCS-2 vai UCS-4. Suurimman tuetun
  unicodemerkin arvon voi kysyä näin:<br>
  sys.maxunicode.</p>

  <p>Joukkotyypit:</p>

  <table border="1" summary="Joukkotyypit">
    <tr>
      <th>Tyyppi</th>

      <th>Tarkoitus</th>

      <th>Esimerkki</th>
    </tr>

    <tr>
      <td><code>set</code></td>

      <td>joukot</td>

      <td><code>set([32, 26, 12, 54])</code></td>
    </tr>

    <tr>
      <td><code>frozenset</code></td>

      <td>immutaabelit joukot</td>

      <td><code>set([32, 26, 12, 54])</code></td>
    </tr>
  </table>

  <p>Kuvaustyypit:</p>

  <table border="1" summary="Kuvaustyypit">
    <tr>
      <th>Tyyppi</th>

      <th>Tarkoitus</th>

      <th>Esimerkki</th>
    </tr>

    <tr>
      <td><code>dict</code></td>

      <td>avain: arvo -parit</td>

      <td><code>{"one": 1, "two": 2}</code></td>
    </tr>
  </table>

  <h3 id="chapter-5-vahva-heikko-tyypitys">5.2. Vahva tyypitys ~ heikko
  tyypitys</h3>

  <p>Python voidaan luokitella vahvasti tyypitetyksi kieliksi. Sen
  vahvoihin tyyppiturvallisuusominaisuuksiin kuuluu muun muassa,
  että implisiittisiä tyyppimuunnoksia ei käytetä (lähes
  ollenkaan?) ja olioilla on aina tyyppi, eikä sitä voi muuttaa
  (muuttujilla ei ole tyyppiä). Vrt. Javassa <code>"spam" +
  1</code> tuottaa merkkijonon <code>"spam1"</code>. Pythonissa ei
  numeroa suostuta implisiittisesti konvertoimaan vaan tuloksena on
  poikkeus. Vastaavasti C:ssä voidaan esimerkiksi osoittimet
  konvertoida eksplisiittisesti ja siten käytännössä tulkita mikä
  tahansa olio miksi tahansa olioksi.</p>

  <p>Objektien tyyppiä ei tarkisteta käännösaikana, vaan ajon
  aikana jotkut operaatiot voivat epäonnistua (jolloin syntyy
  poikkeus), mikä osoittaa, että objekti ei ole sopivaa
  tyyppiä.</p>

  <h3 id="chapter-5-stat-dyn-tyypitys">5.3. Staattinen tyypitys ~ dynaaminen
  tyypitys</h3>

  <p>Python on dynaamisesti tyypitetty kieli. Vaikka olioiden
  tyyppi onkin aina tiedossa, niin Pythonilla ohjelmoitaessa tämä
  yritetään jättää mahdollisimman pitkälti huomiotta. Muuttujalla
  ei ole ennalta määrättyä tyyppiä. Funktioiden parametrien tyyppiä
  ei normaalisti tarkisteta vaan noudatetaan ns. <em>duck typing</em>
  -paradigmaa, jonka ajatus on, että "Jos se vaakkuu kuin ankka ja
  kävelee kuin ankka, niin sen täytyy olla ankka." Olion (Pythonissa
  kaikki ovat olioita) tyyppi määritellään tutkimalla sen metodeita
  ja attribuutteja. Tyypillisesti käytetään EAFP (Easier to Ask
  Forgiveness than Permission) -tyyliä. Kun jotakin metodia
  yritetään käyttää, ei olion tyyppiä tarkisteta etukäteen, vaan
  käytetään mielummin poikkeuksia. Lyhyesti ideana on siis se, että
  ei välitetä siitä, mistä olio on periytynyt, vaan siitä, pystyykö
  se suorittamaan halutun tehtävän. Seuraavassa esimerkki <em>duck
  typing</em> -paradigman käytöstä:</p>
  <pre class="sh_python">
class Duck:
    def quack(self):
        print("Quaaaaaack!")
    def duck_walk(self):
        print("Walks.")
 
class Person:
    def quack(self):
        print("The person quacks like a duck.")
    def duck_walk(self):
        print("The person walks like a duck.")
    def name(self):
        print("John Smith")
 
def in_the_forest(duck):
    duck.quack()
    duck.duck_walk()
 
def game():
    donald = Duck()
    john = Person()
    in_the_forest(donald)
    in_the_forest(john)
 
game()
</pre><!-- Merkkaa lähteet Timo
  http://en.wikipedia.org/wiki/Type_safety
  http://en.wikipedia.org/wiki/Strong_typing
  http://en.wikipedia.org/wiki/Duck_typing
  http://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language
  -->

  <p>Muuttujan tyypin voi tarvittaessa tarkistaa
  <code>isinstance</code> -funktiolla. <code>isinstance</code>
  tarkistaa onko sille parametrina annettu muuttuja parametrina
  annetun tyypin tai luokan instanssi. Seuraavassa esimerkkejä sen
  käytöstä Python -konsolissa:</p>
  <pre>
&gt;&gt;&gt; isinstance(42, str)
False
&gt;&gt;&gt; isinstance('stringi', int)
False
&gt;&gt;&gt; isinstance(42, int)
True
&gt;&gt;&gt; isinstance('stringi', str)
True
</pre>

  <h2 id="chapter-6">6. Laskennan kapselointi</h2>

  <p><em>miten toiminnallisuuksia abstrahoidaan ja niistä
  rakennetaan uusia toiminnallisuuksia?</em></p>

  <ol class="sub-toc">
    <li><span>6.1.</span><a href="#chapter-6-aliohjelmat">Nimetyt aliohjelmat ja/tai
    alifunktiot</a></li>

    <li><span>6.2.</span><a href=
    "#chapter-6-parametrivalitys">Parametrivälitys</a></li>

    <li><span>6.3.</span><a href="#chapter-6-poikkeukset">Suoritusaikaisiin
    virheisiin varautumisen välineet – poikkeukset</a></li>

    <li><span>6.4.</span><a href="#chapter-6-rinnakkaislaskenta">Miten kieli tukee
    rinnakkaista laskentaa</a></li>
    
    <li><span>6.5.</span><a href="#chapter-6-generaattorit">Generaattorit</a></li>
    
    <!--TODO: Kaks vikaa kappaletta puuttuvat? -->
    <li><span>6.6.</span><a href="#chapter-6-ohjelmaarkkitehtuurit">Tyypillisiä
    ohjelma-arkkitehtuureja</a></li>

    <li><span>6.7.</span><a href="#chapter-6-arvio">Arvio kieleen valittujen
    ratkaisujen eduista ja haitoista</a></li>
  </ol>

  <h3 id="chapter-6-aliohjelmat">6.1. Nimetyt aliohjelmat ja/tai
  alifunktiot</h3>

  <p>Funktio määritellään avainsanalla <i>def</i>, jota tulee
  seurata funktion nimi ja muodolliset parametrit. Funktio on siis
  muotoa <i>def</i> [nimi] <i>(</i>[parametrit]<i>)</i>, ja
  normaaliin Python tapaan lohkon merkiksi tulee kaksoispiste.
  Funktion rungon muodostavat lausekkeet alkavat seuraavalta
  riviltä ja niiden tulee olla sisennettyinä.</p>

  <p>Pythonissa on sallittu sisäkkäiset funktiomäärittelyt.
  Funktion <i>f1</i> sisällä määritelty funktio <i>f2</i> pääsee
  käsiksi f1:n muuttujiin. Jos f2 määrittelee päällekkäisiä nimiä
  f1:n kanssa, ympäröivän funktion nimet peittyvät. Näkyvyyksistä
  on kerrottu tarkemmin <a href="#chapter-3">luvussa 3</a></p>

  <p>Funktion ensimmäinen lause voi olla string-literaali, jolloin
  se toimii funktion dokumentaatiomerkkijonona eli
  <i>docstringinä</i>.</p>
  <pre class="sh_python">
def funktio(viesti):
    """Funktion docstring"""
    print(viesti)
  
</pre>

  <p>Pythonissa kaikki funktiot palauttavat arvon, myös sellaisissa
  tapauksissa, kun funktiolla ei ole <i>return</i> lausetta. Ilman
  return-lausetta funktiot palauttavat arvon <i>None</i>. [<a href=
  "#ref-funktiot">16</a>]</p>

  <h3 id="chapter-6-parametrivalitys">6.2 Parametrivälitys</h3>

  <p>Pythonissa parametrinvälitys on toteutettu olioviitteillä,
  jotka välitetään arvoparametreinä. Joidenkin olioiden arvo voi
  muuttua. Oliota, jonka arvo voi muuttua, kutsutaan
  <em>mutaabeliksi</em> olioksi, vastaavasti muuttumatonta oliota
  kutsutaan <em>immutaabeliksi</em> olioksi. Olion muuttumattomuus
  määräytyy sen tyypin mukaan. Esimerkiksi numeeriset tyypit,
  stringit ja monikot ovat muuttumattomia, mutta dict- ja
  list-rakenteet ovat muuttuvia.</p>

  <p>Seuraavassa esimerkki parametrinvälityksestä:</p>
  <pre class="sh_python">
def muuta1(y):
    print('muuta1 sai', y)
    y = [1, 2, 3]
    print('muuta1 muutti y arvoksi', y)
    
def muuta2(y):
    print('muuta2 sai', y)
    y.append(3)
    print('muuta2 muutti y arvoksi', y)
        
def muuta3(y):
    print('muuta3 sai', y)
    y = "egg and bacon"
    print('muuta3 muutti y arvoksi', y)    

# pääohjelma
x = [1, 2]
print('ennen muuta1 x arvo on', x)
muuta1(x)
print('muuta1 jälkeen x arvo on', x)

x = [1, 2]
print('ennen muuta2 x arvo on', x)
muuta2(x)
print('muuta2 jälkeen x arvo on', x)

x = "spam spam spam"
print('ennen muuta3 x arvo on', x)
muuta3(x)
print('muuta3 jälkeen x arvo on', x)

# ohjelman tulostus 
'''
ennen muuta1 x arvo on [1, 2]
muuta1 sai [1, 2]
muuta1 muutti y arvoksi [1, 2, 3]
muuta1 jälkeen x arvo on [1, 2]
ennen muuta2 x arvo on [1, 2]
muuta2 sai [1, 2]
muuta2 muutti y arvoksi [1, 2, 3]
muuta2 jälkeen x arvo on [1, 2, 3]
ennen muuta3 x arvo on spam spam spam
muuta3 sai spam spam spam
muuta3 muutti y arvoksi egg and bacon
muuta3 jälkeen x arvo on spam spam spam
'''
</pre>

  <p>Funktio muuta1 yrittää muuttaa saamansa listaparametrin
  arvoksi <code>[1, 2, 3]</code> sijoittamalla siihen uuden
  listainstanssin, mutta tämä ei toimi vaikka listarakenne onkin
  mutaabeli, koska <code>y = [1, 2, 3]</code> korvaa vain
  parametrimuuttujan paikallisen kopion arvon.
  <code>muuta2</code>-funktio muuttaa onnistuneesti listaparametrin
  arvoksi <code>[1, 2, 3]</code> käyttämällä listaolion
  append-metodia.</p>

  <p>String-tyyppi on Pythonissa muuttumaton, joten muuta3-funktion
  tyylinen stringin uudelleensijoitus parametriin ei myöskään
  toimi.</p>

  <p>Python tukee tavallisen parametrien lisäksi vaihtuvan
  mittaisia parametrilistoja ja nimettyjä parametrejä.
  Parametrilista otetaan käyttöön erikoissyntaksilla
  <code>*args</code>, jossa <code>args</code> on parametrit
  sisältävä listamuuttuja. Vastaavasti nimetyt parametrit otetaan
  käyttöön <code>**kwargs</code> syntaksilla, jossa
  <code>kwargs</code> sisältää nimetyt parametrit
  <code>dict</code>-avainarvorakenteessa. Seuraavassa esimerkki
  niiden käytöstä:</p>
  <pre class="sh_python">
def tulosta_kaikki(a, b, *c, **d):
    print('tavalliset parametrit: ', a, b)
    print('listaparametrit: ')
    for arg in c:
        print(arg)
    print('nimiparametrit: ')
    for kwarg in d.items():
        print(kwarg)

# pääohjelma
c = [1, 2, 3, 4]
d = {'pi': 3.14, 'e': 2.72}

tulosta_kaikki('eka', 'toka', *c, **d)
# sama kuin: 
# tulosta_kaikki('eka', 'toka', c[0], c[1], c[2], c[3], pi=3.14, e=2.72)

# ohjelman tulostus 
'''
tavalliset parametrit:  eka toka
listaparametrit: 
1
2
3
4
nimiparametrit: 
('pi', 3.14)
('e', 2.72)
'''
</pre>

  <p>Pythonissa voidaan käyttää myös oletusparametreja [<a href=
  "#ref-funktiot">16</a>], jolloin funktiota voidaan kutsua
  pienemmällä määrällä parametreja kuin mitä on mainittu sen
  määrittelyssä.</p>
  <pre class="sh_python">
def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries &lt; 0:
            raise IOError('refusenik user')
        print(complaint)
        
# Edellä mainittua koodia olisi mahdollista kutsua esimerkiksi seuraavilla tavoilla:
#
# ask_ok('Do you really want to quit?')
# ask_ok('OK to overwrite the file?', 2)
# ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')
</pre>

  <p>Oletusarvot evaluoidaan määrittelykohdassaan omalla
  näkyvyysalueellaan.</p>
  <pre class="sh_python">
i = 5

def f(arg=i):
    print(arg)

i = 16
f() # Tulostaa arvon 5
</pre>

  <p>Oletusarvot sidotaan vain kerran. Tällä on väliä varsinkin jos
  oletusarvona käytetään mutaabelia oliota kuten esim. listaa tai
  sanakirjaa.</p>
  <pre class="sh_python">
  def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))

# Koodi tulostaa:
#
# [1]
# [1, 2]
# [1, 2, 3]
</pre>

  <p>Funktioita voidaan myös kutsua käyttämällä nimettyjä
  parametreja [<a href="#ref-funktiot">16</a>] esim.
  <code>parametrin_nimi = arvo</code>, jolloin arvot voidaan
  järjestellä kutsujan haluamaan järjestykseen.</p>
  <pre class="sh_python">
def foo(bar,fuu):
    print("BAR: {}".format(bar))
    print("FUU: {}".format(fuu))

foo("Eka", "Toka")
foo(fuu = "Toka", bar = "Eka")
foo("Eka", fuu = "Toka")

# Kaikki tulostavat saman eli:
#
# BAR: Eka
# FUU: Toka
</pre>

  <h3 id="chapter-6-poikkeukset">6.3. Suoritusaikaisiin virheisiin
  varautumisen välineet – poikkeukset</h3>

  <p>Python 3:n poikkeuksien käsittely toimii niin tavanomaisesti,
  että ainoastaan Python 2 -ohjelmoija voi pitää sitä jotenkin
  odottamattomana. Python 2:sta stacktrace tallennettiin globaaliin
  muuttujaan ja tästä seurasi, että mikäli poikkeus syntyi ja
  poikkeuksen käsittelyn aikana syntyi toinen poikkeus, niin
  ensimmäisen poikkeuksen stacktrace katosi, jollei ohjelmoija
  ollut itse laittanut sitä jonnekin talteen. Näin kävi myös jos
  poikkeuskäsittelijässä paketoi käsitellyn poikkeuksen toiseen
  poikkeukseen. Tämä Python 2:den ominaisuus ei periytynyt Python
  3:een. Siispä poikkeukset käyttäytyvät Python 3:ssa hyvin
  Javamaiseen tapaan. Suurimmat erot muihin kieliin lienevät
  syntaktisia tai toteutuksen yksityiskohtia.</p>
  <pre class="sh_python">
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

class NegativeNumberError(Exception):
    pass    #Meille riittää tässä yksinkertaisen tavallisen poikkeuksen toteutus, joten jätetään tämä määrittely tyhjäksi

def main():
    try:
        print("Anna positiivinen luku:")
        jakaja = int(input())
        if jakaja &lt; 0:
            raise NegativeNumberError("Negatiivinen numero ei ole tässä sallittu")
        1/jakaja
    except ZeroDivisionError as e:  #Tässä käsitellään vain ZeroDivisionErrorit ja poikkeus-olio välitetään käsittelevään lohkoon as-avainsanan avulla muuttujassa e
        #Seuraavassa muutamia tapoja päästä poikkeuksen tietoihin käsiksi
        import sys, traceback
        print(e.__class__.__name__)
        print(e)
        print(e.__cause__)
        print(e.__context__)
        print(e.__traceback__)
        print(sys.exc_info())
        traceback.print_tb(e.__traceback__)
    except (ValueError, NegativeNumberError): #Käsittelijä voidaan määrittää käsittelemään useamman tyyppisiä poikkeuksia.
        print("ValueError tai NegativeNumberError")
        raise
    except ZeroDivisionError:   #Tätä käsittelijää ei suoriteta koskaan, sillä käsittelijöistä valitaan aina vain yksi ja se on ensimmäinen
        #ylhäältä alas katsottuna, joka kelpaa poikkeuksen käsittelyyn.
        print("Tänne ei päädytä koskaan")
    except: #Oletus "catch"-haara. Tänne päästään ainakin ajamalla ohjelma ja jos syötteen annon sijasta painetaan ctrl + c tai ctrl + d
        print("Jokin muu meni pieleen")
    #except Exception:   #Tämä ei menisi kääntäjästä läpi, sillä oletuskäsittelijän (pelkkä except:) jälkeen ei saa määritellä enää käsittelijöitä.
    #    print("Tänne ei ole laillista")
    finally:    #Tämän haaran koodi kaikissa tapauksissa.
        print("Tämä printataan aina")

if __name__ == "__main__":
    main()
    
  
</pre><a href="esimerkit/poikkeukset.py">Lataa esimerkki tästä.</a>

  <p>Ohjelman tulosteet eri syötteillä:</p>

  <dl>
    <dt>0</dt>

    <dd>
      <pre>
Anna positiivinen luku:
0
ZeroDivisionError
int division or modulo by zero
None
None
&lt;traceback object at 0x920ff2c&gt;
(&lt;class 'ZeroDivisionError'&gt;, ZeroDivisionError('int division or modulo by zero',), &lt;traceback object at 0x920ff2c&gt;)
  File "./esimerkit/poikkeukset.py", line 13, in main
    1/jakaja
Tämä printataan aina
  
</pre>
    </dd>

    <dt>-1</dt>

    <dd>
      <pre>
Anna positiivinen luku:
-1
ValueError tai NegativeNumberError
Tämä printataan aina
Traceback (most recent call last):
  File "./esimerkit/poikkeukset.py", line 38, in &lt;module&gt;
    main()
  File "./esimerkit/poikkeukset.py", line 12, in main
    raise NegativeNumberError("Negatiivinen numero ei ole tässä sallittu")
__main__.NegativeNumberError: Negatiivinen numero ei ole tässä sallittu
  
</pre>
    </dd>

    <dt>yks</dt>

    <dd>
      <pre>
Anna positiivinen luku:
yks
ValueError tai NegativeNumberError
Tämä printataan aina
Traceback (most recent call last):
  File "./esimerkit/poikkeukset.py", line 38, in &lt;module&gt;
    main()
  File "./esimerkit/poikkeukset.py", line 10, in main
    jakaja = int(input())
ValueError: invalid literal for int() with base 10: 'yks'
  
</pre>
    </dd>

    <dt>ctrl + c</dt>

    <dd>
      <pre>
Anna positiivinen luku:
^CJokin muu meni pieleen
Tämä printataan aina
  
</pre>
    </dd>
  </dl>
  
  <h3 id="chapter-6-generaattorit">Generaattorit (<code>yield</code>)</h3>
  
  <p>Generaattorit ovat yksinkertainen työkalu iteraattorien
  luomiseen [<a href="#ref-generators">29</a>], joita voi tietenkin luoda muillakin keinoilla. Ne luodaan samaan
  tapaan kuin tavalliset funktiot, mutta niissä käytetään <code>return</code>
  -lauseen sijasta <code>yield</code> -lausetta. Kutsuttaessa
  generaattorin <code>next()</code> -funktiota, se jatkaa suoritusta siitä mihin
  se edellisellä kerralla jäi ja palauttaa arvon kohdatessaan jälleen <code>yield</code> -lauseen.</p>
  
  <p>Generaattoreille luodaan automaattisesti iteraattoreista tyypillisesti löytyvät <code>__iter__()</code> and <code>__next__()</code> -metodit. Suorituksen tila ja paikallisten muuttujien arvot jäävät muistiin. Generaattorien suorituksen loppuessa nostetaan automaattisesti <code>StopIteration</code> poikkeus, joka kertoo kutsujalle iteroinnin loppumisesta.</p>
  
  <p>Seuraavaksi esimerkki fibonaccin lukujen laskemisesta generaattorin avulla:</p>
  <pre class="sh_python">
def fib(n):
    """Palauttaa Fibonaccin lukuja, kunnes saavutetaan luku, joka on suurempi kuin syöttöluku."""
    yield 0
    a, b = 0, 1
    while b <= n:
        a, b = b, a+b
        yield a

for f in fib(20):
    print(f)
</pre>

  <p>Edellinen koodi tulostaa:</p>
  
  <pre>
0
1
1
2
3
5
8
13
</pre>

  <h3 id="chapter-6-rinnakkaislaskenta">6.4. Miten kieli tukee
  rinnakkaista laskentaa</h3>

  <p>Python ei erityisemmin tue rinnakkaisuutta. Pythonissa
  (ainakin CPython implementaatiossa) on käytössä GIL eli Global
  Interpreter Lock. GIL:in tarkoitus on yksinkertaisesti estää
  Pythonin bytecoden rinnakkainen suorittaminen. Tämä tarkoittaa
  sitä, että riippumatta siitä montako ydintä/prosessoria on
  käytettävissä ja moneenko säikeeseen Python-ohjelman suoritus on
  jaettu, samanaikaisesti voi kuitenkin yleensä suorittaa vain yksi
  säie. Ratkaisuun on päädytty siksi, että CPython
  implementaatiosta on näin saatu paljon tehokkaampi ja myös
  yksinkertaisempi. Aikaisemmin CPythonista kokeiltiin versiota,
  joka jossa GIL oli poistettu, mutta sen katsottiin heikentävän
  aivan liikaa Pythonin tehokkuutta yksiytimisillä järjestelmillä
  (ainakin 30% tehottomampi). Toistaiseksi tähän ei ole
  odotettavissa mitään muutosta. Tämä ei toki tarkoita, etteikö
  Pythonilla voitaisi saavuttaa aitoa rinnakkaisuutta.
  Rinnakkaisuuteen on vain käytettävä prosesseja tai C/C++
  laajennoksia joissa GIL vapautetaan. Myös esimerkiksi
  IO-operaatioiden yhteydessä GIL vapautetaan, joten tiedostoja voi
  lukea eri säikeissäkin aidosti rinnakkain. Mielenkiintoinen
  kysymys on kuinka pitkälle nykyinen kanta pitää, kun yksiytimiset
  prosessorit tulevat yhä harvinaisemmiksi ja lopulta katoavat
  kokonaan historiaan. <a href="#ref-gil-ref">[14]</a><a href=
  "#ref-gil-faq">[15]</a></p>

  <p>Seuraavassa vielä pieni demonstraatio siitä mitä tämä
  tarkoittaa.</p>
  <pre class="sh_python">
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

from multiprocessing import Pool
from multiprocessing.pool import ThreadPool
import multiprocessing
import time

tyypit = ["Bob Sagget", "Cloris Leachman", "Norm MacDonald", "Greg Ricardo", "Gilbert Gottfried"]
tulokset = {}

def tee_jotain(name):
    for i in range(1,4):
        #Mikäli tässä olisi vain nukuttu sen sijaan, että tuhlataan hieman prosessoriaikaa, niin tulos
        #olisikin ollut se, että säikeet olisivat olleet nopeimpia. Ja niinhän sen täytyy olla, sillä
        #tokihan moni säie voi nukkua samaan aikaan ja lisäksi säikeet ovat (jaettu muisti) paljon
        #prosesseja kevyempiä.
        for j in range(1, 1000000):
            if j &gt; 0:
                continue;
            break
        print(i, name)

def moniprosessitesti():
    allas = Pool(5)
    allas.map(tee_jotain, tyypit, 1)
    
def yksiprosessitesti():
    for juippi in tyypit:
        tee_jotain(juippi)
    
def säietesti():
    säieallas = ThreadPool(5)
    säieallas.map(tee_jotain, tyypit, 1)

def main():
    print("Konessa on", multiprocessing.cpu_count(), "prosessoria.")
    
    for testi in [moniprosessitesti, yksiprosessitesti, säietesti]:
        print("\n", testi.__name__)
        aloitus = time.time()
        testi()
        tulokset[testi.__name__] = time.time() - aloitus
        
    print("tulokset:")
    for avain in tulokset:
        print(avain, tulokset[avain])

if __name__ == "__main__":
    main()
</pre><a href="esimerkit/rinnakkaisuus.py">Voit ladata esimerkin
tästä.</a>

  <p>Testin tuloksena omalla Linux-kannettavallani konsoliin
  ilmestyy jotakin tällaista:</p>
  <pre>
Konessa on 2 prosessoria.

 moniprosessitesti
1 Cloris Leachman
2 Cloris Leachman
1 Gilbert Gottfried
1 Bob Sagget
1 Norm MacDonald
1 Greg Ricardo
3 Cloris Leachman
2 Bob Sagget
2 Norm MacDonald
2 Greg Ricardo
2 Gilbert Gottfried
3 Norm MacDonald
3 Gilbert Gottfried
3 Greg Ricardo
3 Bob Sagget

 yksiprosessitesti
1 Bob Sagget
2 Bob Sagget
3 Bob Sagget
1 Cloris Leachman
2 Cloris Leachman
3 Cloris Leachman
1 Norm MacDonald
2 Norm MacDonald
3 Norm MacDonald
1 Greg Ricardo
2 Greg Ricardo
3 Greg Ricardo
1 Gilbert Gottfried
2 Gilbert Gottfried
3 Gilbert Gottfried

 säietesti
1 Greg Ricardo
1 Gilbert Gottfried
1 Bob Sagget
1 Cloris Leachman
1 Norm MacDonald
2 Greg Ricardo
2 Bob Sagget
2 Cloris Leachman
2 Gilbert Gottfried
2 Norm MacDonald
3 Bob Sagget
3 Cloris Leachman
3 Greg Ricardo
3 Gilbert Gottfried
3 Norm MacDonald

tulokset:
yksiprosessitesti 3.42161202431
säietesti 3.89715909958
moniprosessitesti 2.04168510437
</pre>

  <p>Tuloksista nähdään selvästi, että säikeet toimivat kaikista
  hitaimmin. Pelkästään kahdella ytimellä varustettu kannettavani
  toimi prosesseilla lähes 50% nopeammin verrattuna säikeisiin.
  Säikeet toimivat jopa hitaammin kuin yksiprosessitesti.
  Säiealtaan allokointi on toki ylimääräistä työtä, mutta kyseessä
  ei voi olla niin raskas operaatio, että säietesti voisi mitenkään
  päästä lähes puoli sekuntia nopeampaan aikaan ja edes samalle
  viivalle yksiprosessitestin tuloksen kanssa. Kysymys on vain
  siitä, että säikeet eivät tuo mitään aitoa rinnakkaisuutta
  laskentaan vaan ainoastaan lisäävät synkronointitarvetta. GIL:in
  ansiosta synkronointi on toki yksinkertaista, mutta
  prosessoriaikaa pitää silti tasapuolisesti jakaa säikeiden
  välillä ja suoritusvuoroja vaihdella. Kuten kommenteistakin
  ilmenneen, niin mikäli olisimme tulostusten välillä nukkuneet
  silmukassa pyörimisen sijasta olisi säietesti noussutkin
  nopeimmaksi. Tämä johtuu tietenkin siitä, että säikeet ovat
  kevyempiä kuin prosessit ja voivat toki kaikki nukkua samaan
  aikaan siinä missä prosessitkin.</p>

  <h2 id="chapter-7">7. Datan kapselointi</h2>

  <ol class="sub-toc">
    <li><span>7.1.</span><a href="#chapter-7-raktyypit">Rakenteiset ja kapseloidut
    tyypit</a></li>

    <li><span>7.2.</span><a href="#chapter-7-oliotluokat">Oliot ja luokat</a></li>

    <li><span>7.3.</span><a href="#chapter-7-arvosem">Arvo- ja
    viitesemantiikka</a></li>
  </ol>

  <h3 id="chapter-7-raktyypit">7.1. Rakenteiset ja kapseloidut
  tyypit</h3>

  <h4>7.1.1. Moduulit ja paketit</h4>

  <p>Pythonissa lähdekooditiedosto muodostaa moduulin. Moduulin
  nimi on tiedostonimi ilman tiedostopäätettä <code>.py</code>.
  Ajettavan moduulin nimeä voi moduulissa kysyä
  <code>__name__</code> -metodilla. Moduulin tarkoitus on koota
  yhteen määrittelyitä (funktioita, luokkia, muuttujia). Moduuli
  voidaan sitten jostakin toisaalta (esimerkiksi toisesta
  moduulista) pyytää käytettäväksi. Moduuli voidaan pyytää käyttöön
  avainsanan <code>import</code> avulla. Tämä voidaan tehdä
  esimerkiksi näin:</p>
  <pre class="sh_python">
import moduuli
  
#kutsutaan
moduuli.moduulissa_määritelty_funktio()
</pre>

  <p>Kuten esimerkistä nähdään, niin moduulissa määriteltyjä
  asioita ei tuoda suoraan osaksi sen hetkistä symbolitaulua, vaan
  ainoastaan moduulin nimi tuodaan sinne ja sen sisältöön viitataan
  sitä kautta. Toisenlaista käytöstä saadaan aikaan, jos
  yksinkertaisesti määritellään nimi myös sellaisenaan
  symbolitauluun. Eli vaikkapa näin:</p>
  <pre class="sh_python">
import moduuli
  
#määritellään nimi moduulissa_määritelty_funktio viittaamaan
#moduulin moduuli sisällä määriteltyyn funktioon moduulissa_määritelty_funktio
moduulissa_määritelty_funktio = moduuli.moduulissa_määritelty_funktio

#ja nyt voimme viitata funktioon suoraan ilman moduulia
moduulissa_määritelty_funktio()
</pre>

  <p>Yllä esitettyä tapaa elegantimpi tapa tuoda nimiä lokaaliin
  nimiavaruuteen on käyttää <code>import</code> -lauseen
  erityismuotoa. Voidaan sanoa <code>from module import
  moduulissa_määritelty_funktio</code>. Tämä ei toki ole aivan sama
  kuin yllä, sillä tässä tapauksessa vain ja ainoastaan tämä yksi
  funktio liitetään moduulista osaksi tätä moduulia ja siten siis
  mitkään muut moduulin nimet eivät ole edes moduulin nimen kautta
  viitattavissa tässä nimiavaruudessa.</p>

  <p>Jos kuitenkin kaikki moduulin nimet halutaan tuoda toisen
  moduulin lokaaliin nimiavaruuteen sellaisenaan, niin tämäkin on
  mahdollista. Tällöin käytetään edellisen <code>import</code>
  -lauseen variantin erikoismuotoa. Eli sanomme: <code>from moduuli
  import *</code>.</p>

  <p>Python ei ilmeisesti tue piirreluokkia (<em>eng. trait</em>).
  Kuitenkin näyttäisi siltä, että Pythonillakin tätä tekniikkaa
  voidaan jossain määrin matkia moduulien avulla. Esimerkiksi
  luokan funktiot voidaan määritellä erillisessä moduulissa ja
  sitten sisällyttää luokan määrittelyssä ne toisesta moduulista
  osaksi lokaalia nimiavaruutta. Seuraavassa yksinkertainen
  esimerkki:</p>
  <pre class="sh_python">
*- coding: UTF-8 -*- # moduuli1.py class Luokka:
  from moduuli2 import tee_jotain def tee_jotain_muuta(self):
  print("Moduulissa 1 määritelty") def main(): l = Luokka()
  l.tee_jotain() l.tee_jotain_muuta() if __name__ == "__main__":
  main() #!/usr/bin/python3.1 # -*- coding: UTF-8 -*- # moduuli2.py
  def tee_jotain(self): print("Moduulissa 2 määritelty")
</pre>

  <p>Suorittamalla moduuli1.py-moduulin skriptinä konsolissa,
  tulostuu konsoliin:</p>
  <pre>
Moduulissa 2 määritelty
Moduulissa 1 määritelty
</pre>

  <h4>7.1.2. Paketit (<em>Packages</em>) ja alimoduulit
  (<em>submodules</em>)</h4>

  <p>Monista moduulien muodostaman kokonaisuuden voi koota
  paketiksi. Paketit ovat erityistä tiedostorakennetta noudattavia
  hakemistoja. Pakein nimi on sen juurihakemiston nimi.
  Juurikansion tulee sisältää __init__.py -tiedosto sen merkiksi,
  että kyseessä on paketti. Samoin myös kaikkien alikansioiden
  (joiden halutaan olevan osa pakettia) tulee sisältää tämä
  tiedosto. __init__.py voi kuitenkin olla tyhjä. Esimerkki paketin
  hakemistorakenteesta:</p>
  <pre>
paketin_juuri/
paketin_juuri/__init__.py
paketin_juuri/alipaketti/__init__.py
paketin_juuri/alipaketti/alimoduuli.py
</pre>

  <p>Nyt alimoduuliin voidaan viitata vaikkapa näin:<br>
  <code>import paketin_juuri.alipaketti.alimoduuli</code><br>
  Mikäli paketeista halutaan tyypillisesti ottaa kerrallaan
  käyttöön kokonainen alipaketti tai koko paketti itsessään, olisi
  luontevaa käyttää tehdä se jotenkin näin:<br>
  <code>from paketin_juuri.alipaketti import *</code><br>
  Ja näin se tehdäänkin. Pakettien etsiminen ja kaikkien tuominen
  voisi olla potentiaalisesti paitsi raskas ja hidas operaatio myös
  aiheuttaa yllättäviä ja vaarallisia sivuvaikutuksia. Ongelma on
  ratkaistu siten, että mikäli paketin ylläpitäjä haluaa
  mahdollistaa tällaisen massasisällyttämisen (mass include), niin
  hänen tulee määritellä kunkin tason __inti__.py-tiedostossa
  muuttujan <code>__all__</code> arvoksi lista niistä
  alimoduuleista, jotka tulisi tällöin sisällyttää.</p>
  <!-- TODO: Listat, dictit, tuplet yms..? -->
  <!-- TODO: Vois jauhasta sanasen tostakin... <p>
  from collections import namedtuple
  Student = namedtuple('Student', 'name serialnum school gradelevel')
  </p>
  -->

  <h3 id="chapter-7-oliotluokat">7.2. Oliot ja luokat</h3>

  <p>Pythonissa luokat ovat olioita, kuten kaikki muutkin
  tietotyypit. Luokat ovat myös dynaamisia: ne luodaan
  ajoaikaisesti, ja niitä voidaan muokata luomisen jälkeenkin.
  Luokkien jäsenmuuttujat ovat normaalisti julkisia [<a href=
  "#ref-classes">21</a>], eikä Pythonissa ole mahdollista piilottaa
  dataa,
  [http://docs.python.org/py3k/tutorial/classes.html#random-remarks]
  vaan kaikki perustuu ohjelmointikäytäntöihin. Privaattien
  muuttujien luomiseen on rajallinen tuki: kirjoittamalla muuttujan
  nimen eteen kaksi alaviivaa saadaan muuttuja käyttäytymään, ikään
  kuin se olisi privaatti ( esim: <code>__spam</code>). [<a href=
  "#ref-private">22</a>]</p>

  <p>Jos data-attribuutilla ja metodilla on sama nimi, metodin nimi
  peittyy. Nimiongelmien välttämiseksi suositellaan käyttämään
  jonkinlaista nimeämiskäytäntöä, esimerkiksi nimeämällä metodit
  niin, että nimi alkaa isolla kirjaimella. [<a href=
  "#ref-random">23</a>]</p>

  <p>Luokkamäärittely yksinkertaisimmillaan:</p>
  <pre class="sh_python">
class ClassName:
    &lt;lause-1&gt;
    .
    .
    .
    &lt;lause-N&gt;
</pre>

  <p>Luokkamäärittelyihin pätee sama kuin funktioidenkin
  määrittelyihin: ne tulee suorittaa, ennen kuin niitä voidaan
  käyttää ohjelmassa. (Jos luokkamäärittely on laitettu
  <code>if</code> -lauseen sisään, sitä ei voida käyttää ennen kuin
  <code>if</code> -lause on suoritettu) Kun luokkamäärittelystä
  poistutaan normaalisti, syntyy luokkaolio. [<a href=
  "#ref-classdefinition">24</a>]</p>

  <h4>7.2.1. Self</h4>

  <p>Pythonissa <code>self</code> vastaa Javan
  <code>this</code>-käskyä. Sillä viitataan luokan nykyiseen
  ilmentymään. Se tulee antaa jokaisessa metodimäärittelyssä
  metodin ensimmäiseksi parametriksi, vaikka kutsuttaessa metodia
  <code>self</code> -parametrille ei anneta arvoa (Python hoitaa
  itse tämän). <code>self</code> ei ole varattu sana, joten sen
  tilalla voitaisiin käyttää muutakin, mutta koodin luettavuuden
  vuoksi sen käyttöä suositellaan.</p>
  <pre class="sh_python">
class Luokka:
    def metodi(self, parametri1, parametri2):
        ...
</pre>

  <p>Self:in toiminta voi tuntua hieman kummalliselta, joten
  selvennykseksi pieni esimerkki: Jos on määritelty luokka
  <code>Luokka</code> ja siitä on olemassa ilmentymä
  <code>olio</code>. Kun kutsutaan tuon ilmentymän metodia
  <code>olio.metodi(parametri1, parametri2)</code> kutsu muutetaan
  automaattisesti muotoon <code>Luokka.metodi(olio, parametri1,
  parametri2)</code>. [<a href="#ref-self">25</a>] [<a href=
  "#ref-method">26</a>]</p>

  <h4>7.2.2. Luokkaoliot</h4>

  <p>Luokkaoliot tukevat kahdenlaisia operaatioita:
  <i>attribuuttiviittauksia</i> ja <i>ilmentymien luomista</i>.
  [<a href="#ref-classobject">27</a>]</p>

  <p>Attribuuttiviittauksessa syntaksi on <code>olio.nimi</code>.
  Esimerkkinä olevan luokkamäärittelyn tapauksessa
  <code>Luokka.i</code> palauttaisi kokonaisluvun ja
  <code>Luokka.metodi</code> palauttaisi funktio-olion
  (<code>Luokka.metodi(Luokka)</code> palauttaisi merkkijonon
  "spam").</p>
  <pre class="sh_python">
class Luokka:
    i = 1
    def metodi(self):
        return 'spam'
</pre>

  <p>Ilmentymien luominen toimii kuin luokkaolio olisi parametriton
  funktio, joka palauttaa luokan uuden ilmentymän.</p>
  <pre>
x = Luokka()
</pre>

  <p>Luokkaan voidaan määritellä erikoismetodi
  <code>__init__()</code>, jota kutsutaan automaattisesti, kun olio
  on luotu. <code>__init__()</code>:n avulla ilmentymä voidaan
  alustaa johonkin haluttuun tilaan.</p>
  <pre class="sh_python">
class Luvut:
    def __init__(self, luku1, luku2):
        self.r = luku1
        self.i = luku2

x = Luvut(3, 4)
x.r, x.i #tulostaa: (3, 4)
</pre>

  <h4>7.2.3. Ilmentymäoliot</h4>

  <p>Ilmentymäoliot eivät ymmärrä muuta kuin
  attribuuttiviittauksia. Attribuuttinimiä on kahdenlaisia:
  data-attribuutteja ja metodeita.</p>

  <p>Data attribuutit ovat "ilmentymämuuttujia". Ne luodaan kuten
  paikalliset muuttujatkin, eli silloin kun niihin asetetaan jonkin
  arvo. [<a href="#ref-instanceobject">28</a>]</p>

  <h4>7.2.4. Metodioliot</h4>

  <p>Yksinkertainen metodikutsu:</p>
  <pre class="sh_python">
x.metodi() #Luokka -esimerkissä palauttaisi "spam"
</pre>

  <p>Metodia ei ole kuitenkaan pakko aina kutsua suoraan.
  <code>x.metodi</code> on metodiolio, joka voidaan tallentaa
  muuttujaan, jota kutsutaan myöhemmin. [<a href=
  "#ref-method">26</a>]</p>
  <pre class="sh_python">
metodimuuttuja = x.metodi
while True:
    print(metodimuuttuja())
#Tulostaa "loputtomassa" loopissa metodin palauttamaa merkkijonoa
</pre>

  <p>Ajatellaan edelleen, että <code>x</code> on luokan
  <code>Luokka</code> ilmentymä. Tällöin <code>x.metodi</code> ei
  kuitenkaan ole sama asia kuin <code>Luokka.metodi</code>, sillä
  <code>x.metodi</code> on <i>metodiolio</i> ja
  <code>Luokka.metodi</code> on <i>funktio-olio</i>.</p>

  <h4>7.2.5. Periytyminen</h4>

  <p>Pythonissa luokkaperiytyminen on toteutettu seuraavanlaisella
  syntaksilla:</p>
  <pre class="sh_python">
class Luokka(Yliluokka):
    &lt;lause-1&gt;
    .
    .
    .
    &lt;lause-N&gt;
</pre>

  <p>Luokka <code>Luokka</code> perii yliluokan
  <code>Yliluokka</code> jäsenet ja sen yliluokan jäsenet kunnes
  saavutaan <code>object</code> kantaluokkaan. Peritty luokka voi
  korvata yliluokan metodeita yksinkertaisesti määrittelemällä ne
  uudelleen. Yliluokan metodeihin voi viitata
  <code>Yliluokka.metodi(self, parametrit)</code> tyylisellä
  syntaksilla tai Java-tyylisesti
  <code>super()</code>-funktiolla.</p>

  <h4>7.2.6. Moniperiytyminen</h4>

  <p>Pythonissa on mahdollista periyttää luokka monesta luokasta.
  Yleinen syntaksi tähän on sama kuin yhden luokan periytymisessä
  paitsi että periytetyt luokat erotellaan pilkuilla.</p>

  <p>Moniperiytymisen niin kutsuttu <em>timanttiongelma</em> on se,
  että periytettäessä luokka D luokista B ja C, joilla on sama
  isäluokka A, on epäselvää kumman luokan, B vai C, metodeilla
  korvataan isäluokan aliluokissa, B ja C, korvatut jäsenet
  [<a href="#ref-diamond-rule">18</a>]. Pythonissa tämä ongelma on
  ratkaistu periyttämällä kaikki luokat yhteisestä
  <code>object</code> luokasta ja muodostamalla periytymiselle
  tietty periytymisjärjestyslista. Luokkien
  periytymisjärjestyslista muodostetaan hiukan yksinkertaistaen
  läpikäymällä luokat syvyyshaulla vasemmalta oikealle, jonka
  jälkeen listasta poistetaan jo kerran läpikäydyt luokat.</p>

  <p>Seuraavassa esimerkki moniperiytymisestä. Esimerkissä on
  edellä kuvatun kaltainen moniperintätilanne luokista A, B, C ja
  D. Luokka D periytetään luokista B ja C. Periytymishakujärjestys
  on tässä tapauksessa lista <code>[D, B, A, C, A]</code>, joka
  supistuu muotoon <code>[D, B, C, A]</code>, kun kaksoiskappaleet
  poistetaan niin että vain viimeinen viittaus luokkaan jää
  jäljelle listaan.</p>
  <pre class="sh_python">
# Kuvio luokkamallista
#
#    A
#   / \
#  B   C
#   \ /
#    D

class D(B, C):
    &lt;lause-1&gt;
    .
    .
    .
    &lt;lause-N&gt;
</pre><!-- TODO: Lähteet kuntoon -->
  Lähteenä: http://docs.python.org/tutorial/modules.html

  <h3 id="chapter-7-arvosem">7.3. Arvo- ja viitesemantiikka</h3>

  <p>Muuttujat Pythonissa sisältävät pelkästään viittauksen olioon
  [<a href="#ref-call-by-ref">17</a>]. Viittauksen kohteena olevat
  oliot sisältävät myös tyyppitietonsa eli minkä luokan olion
  ilmentymä on kyseessä. Esimerkiksi funktiokutsussa annettu
  parametri on siis vain viittaus johonkin olioon, joka kuten
  aiemmin on jo mainittu, on joko immutaabeli tai ei. Kutsuttu
  funktio ei voi muuttaa kutsujansa olioviitettä, eli esimerkiksi
  seuraavanlainen funktio ei pystyisi muuttamaan alkuperäistä
  stringiä ollenkaan, vaan sen tulisi palauttaa viite uuteen string
  -olioon.</p>
  <pre class="sh_python">
def muuta_str(s):
    s = "Uusi stringi" # funktion paikallinen muuttuja viittaamaan uuteen olioon

a = "asdf"
muuta_str(a)
</pre>

  <p>Muuttujaan sijoittaminen (esimerkiksi <code>a = b</code>)
  asettaa muuttujan osoittamaan, tyypistä riippumatta, johonkin
  olioon. Mutaabeleja olioita voidaan muuttaa muutosoperaatioilla
  kutsutussa metodissa.</p>
  <pre class="sh_python">
def add_bananas(l):
    l.append("bananas")

a = ["apples", "tomatoes"]
add_bananas(a) # a = ['apples', 'tomatoes', 'bananas']
</pre>

  <p>Muuttujan arvon sijoittaminen eli arvon kopiointi suoritetaan
  <code>copy</code> pakkauksen <code>copy</code>- tai
  <code>deepcopy</code>-funktioilla [<a href="#ref-copy">19</a>].
  <code>copy</code>-funktio luo pinnallisen kopion saamastaan
  oliosta ja <code>deepcopy</code> on syväkopion. Pinnallinen kopio
  on uusi olio, jonka sisäisiin olioihin on asetettu viitteet
  vanhan olion viitteisiin. Deepcopy eli syväkopio luo
  rekursiivisesti saamansa olion kaikista viitteistä kopiot.</p>

  <h2 id="chapter-8">8. Yhteenveto</h2>
  <!-- Luennon aikana annetut kommentit 
  
  Ei mitään erityisiä kommentteja
  traitit = piirreluokat
  Viitteet kuntoon eli viittauksia lisää.
  
  -->

  <p>Python on voimakas dynaaminen ohjelmointikieli, jolla on monia
  käyttökohteita. Sen tärkeimpiä ominaisuuksia ovat
  <ul>
    <li>helppolukuisuus</li>
    <li>modulaarisuus</li>
    <li>intuiivinen luokkamalli</li>
    <li>introspektio kyvyt</li>
    <li>poikkeustenkäsittely</li>
    <li>korkean tason datatyypit</li>
    <li>laaja standardikirjasto</li>
    <li>laajennettavuus C/C++-koodilla</li>
    <li>ilmainen (opensource)</li>
  </ul>
  [<a href="#ref-about">20</a>]</p>

  <p>Pythonia käytetään usein skriptikielenä sen
  helppokäyttöisyyden ja joustavuuden takia. Esimerkiksi monet
  Linux-distribuutiot käyttävät Pythonia asennuksessaan tai
  paketointijärjestelmän toteutuksessa. Python toimitetaankin
  nykyään jo usein Linux-distribuution mukana.</p>

  <p>Python-tulkki sulautetaan usein ohjelmien sisään
  skriptausrajapinnaksi. Esimerkiksi 3D-mallinnusohjelma Blender,
  rasteripiirto-ohjelma GIMP ja jotkin tietokonepelit hyödyntävät
  Pythonia näin. Web-ohjelmointia varten on kehitetty monia
  ohjelmistokehyksiä kuten Django, Pylons, TurboGears, web2py,
  Flask ja Zope. Niitä voidaan käyttää web-palvelinten kuten
  Apachen kanssa WSGI:n kautta, joka on erikseen Pythonin ja
  palvelinten välistä vuorovaikutusta varten kehitetty rajapinta.
  Tieteellistä laskentaa varten on olemassa NumPy, SciPy ja monia
  muita kirjastoja.</p>

  <p>Pythonin dynaamisen tyypitysjärjestelmän kääntöpuoli on että
  mahdolliset virheet koodissa huomataan vasta suoritusaikana,
  syntaksivirheitä lukuun ottamatta, eikä käännösaikana kuten
  monissa muissa kielissä.</p>
  
  <p>Python on nopea kieli tulkattavaksi
  kieleksi, mutta joskus suoritusnopeuskriittinen koodi täytyy
  toteuttaa C/C++-laajennoksilla, jotta se olisi kelvollista. Tämä
  on usein hankalampaa kuin tavallisen Python-koodin
  kirjoittaminen.</p>
  
  <p>Rinnakkaislaskentaa vaivaa Pythonissa GIL, joka
  estää säikeiden suorittamisen samanaikaisesti monella ytimellä.
  GILin poistaminen Pythonista on yhä avoin kysymys, johon ei näytä
  tulevan ratkaisua lähitulevaisuudessa.</p>

  <h2 id="lahteet">Lähteet</h2>

  <ol>
    <li id="ref-varatut-sanat-py3-spec"><a href=
    "http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#keywords">
    http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#keywords</a></li>

    <li id="ref-tunnukset-py3-spec"><a href=
    "http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#identifiers-and-keywords">
    http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#identifiers-and-keywords</a></li>

    <li id="ref-history-of-python"><a href=
    "http://en.wikipedia.org/wiki/History_of_Python">http://en.wikipedia.org/wiki/History_of_Python</a></li>

    <li id="ref-literaalivakiot"><a href=
    "http://docs.python.org/py3k/reference/lexical_analysis.html#literals">
    http://docs.python.org/py3k/reference/lexical_analysis.html#literals</a></li>

    <li id="ref-sulkeumat-py22"><a href=
    "http://docs.python.org/release/2.2.3/whatsnew/node9.html">http://docs.python.org/release/2.2.3/whatsnew/node9.html</a></li>

    <li id="ref-nimet-ja_sidonta-py3-spec"><a href=
    "http://docs.python.org/py3k/reference/executionmodel.html#naming-and-binding">
    http://docs.python.org/py3k/reference/executionmodel.html#naming-and-binding</a></li>

    <li id="ref-ensimmaisenluokan"><a href=
    "http://python-history.blogspot.com/2009/02/first-class-everything.html">
    http://python-history.blogspot.com/2009/02/first-class-everything.html</a></li>

    <li id="ref-controlflow"><a href=
    "http://docs.python.org/py3k/tutorial/controlflow.html">Python
    v3.2 documentation — 4. More Control Flow Tools</a></li>

    <li id="ref-compoundstatement"><a href=
    "http://docs.python.org/py3k/reference/compound_stmts.html">Python
    v3.2 documentation — 7. Compound statements</a></li>

    <li id="ref-library-sys"><a href=
    "http://docs.python.org/py3k/library/sys.html">Python v3.2
    documentation — 27.1. sys — System-specific parameters and
    functions</a></li>

    <li id="ref-tail-recursion"><a href=
    "http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">
    Neopythonic — Tail Recursion Elimination</a></li>

    <li id="ref-stdtypes"><a href=
    "http://docs.python.org/release/3.1.3/library/stdtypes.html">Python
    v3.2 documentation — 5. Built-in Types</a></li>

    <li id="ref-datamodel"><a href=
    "http://docs.python.org/release/3.1.3/reference/datamodel.html">
    Python v3.2 documentation — 3. Data model</a></li>

    <li id="ref-gil-def"><a href=
    "http://docs.python.org/py3k/glossary.html#term-global-interpreter-lock">
    GIL - Global Interpeter Lock</a></li>

    <li id="ref-gil-faq"><a href=
    "http://docs.python.org/py3k/faq/library.html?highlight=gil#can-t-we-get-rid-of-the-global-interpreter-lock">
    Can't we get rid of the Global Identifier Lock?</a></li>

    <li id="ref-funktiot"><a href=
    "http://docs.python.org/release/3.1.3/tutorial/controlflow.html#defining-functions">
    http://docs.python.org/release/3.1.3/tutorial/controlflow.html#defining-functions</a></li>

    <li id="ref-call-by-ref"><a href=
    "http://docs.python.org/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference">
    Python v3.2 documentation » Python Frequently Asked Questions »
    How do I write a function with output parameters (call by
    reference)?</a></li>

    <li id="ref-diamond-rule"><a href=
    "http://docs.python.org/py3k/whatsnew/2.2.html#multiple-inheritance-the-diamond-rule">
    Python v3.2 documentation » What’s New in Python » Multiple
    Inheritance: The Diamond Rule</a></li>

    <li id="ref-about"><a href=
    "http://www.python.org/about/">Python - About</a></li>

    <li id="ref-copy"><a href=
    "http://docs.python.org/library/copy.html">copy — Shallow and
    deep copy operations</a></li>

    <li id="ref-classes"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#classes">http://docs.python.org/py3k/tutorial/classes.html#tut-private</a></li>

    <li id="ref-private"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#tut-private">
    http://docs.python.org/py3k/tutorial/classes.html#tut-private</a></li>

    <li id="ref-random"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#random-remarks">
    http://docs.python.org/py3k/tutorial/classes.html#random-remarks</a></li>

    <li id="ref-classdefinition"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#class-definition-syntax">
    http://docs.python.org/py3k/tutorial/classes.html#class-definition-syntax</a></li>

    <li id="ref-self"><a href=
    "http://www.ibiblio.org/g2swap/byteofpython/read/self.html">http://www.ibiblio.org/g2swap/byteofpython/read/self.html</a></li>

    <li id="ref-method"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#method-objects">
    http://docs.python.org/py3k/tutorial/classes.html#method-objects</a></li>

    <li id="ref-classobject"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#class-objects">
    http://docs.python.org/py3k/tutorial/classes.html#class-objects</a></li>

    <li id="ref-instanceobject"><a href=
    "http://docs.python.org/py3k/tutorial/classes.html#instance-objects">
    http://docs.python.org/py3k/tutorial/classes.html#instance-objects</a></li>
    
    <li id="ref-generators"><a href="http://docs.python.org/py3k/tutorial/classes.html#generators">
    Python v3.2 documentation » The Python Tutorial » Generators</a></li>
    
    <li id="ref-scopes-and-namespaces"><a href="http://docs.python.org/py3k/tutorial/classes.html#python-scopes-and-namespaces">
    Python scopes and namespaces</a></li>
  </ol>

  <p><small>Copyright © 2011 Juhani Åhman, Juha Louhiranta, Matti
  Nauha, Timo Lehto</small></p>

  <p><small><code>import antigravity</code> ;)</small></p>
</body>
</html>
