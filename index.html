<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">

  <title>OKP: Python kevytspesifikaatio</title>
  <meta http-equiv="content-type" content=
  "text/html; charset=utf-8">
</head>

<body>
  <h1>OKP: Python kevytspesifikaatio</h1>

  <p>Kurssi: <a href=
  "http://www.cs.helsinki.fi/u/wikla/OKP/K11/">581362
  Ohjelmointikielten periaatteet, kevät 2011 (4 op)</a></p>

  <h2>Työryhmä</h2>

  <ul>
    <li>Juhani Åhman &lt;juhani.ahman@cs.helsinki.fi&gt;</li>

    <li>Juha Louhiranta &lt;juha.louhiranta@helsinki.fi&gt;</li>

    <li>Matti Nauha &lt;mtnauha@cs.helsinki.fi&gt;</li>

    <li>Timo Lehto &lt;timo.lehto@cs.helsinki.fi&gt;</li>
  </ul>

  <h2>Sisältö</h2>
  <ol>
    <li><a href="#chapter-1">Kielen taustaa ja miniesimerkki</a></li>
    <li><a href="#chapter-2">Alkiorakenne – millaisista palikoista ohjelmat
        rakennetaan</a></li>
    <li><a href="#chapter-3">Tunnusten näkyvyysalueet</a></li>
  </ol>


  <h2 id="chapter-1">1. Kielen taustaa ja miniesimerkki</h2>

  <ul>
    <li><a href="#chapter-1-historia">Historia</a></li>
    <li><a href="#chapter-1-perustietoa">Python perustietoa</a></li>
    <li><a href="#chapter-1-kayttokohteet">Käyttökohteet</a></li>
    <li><a href="#chapter-1-fibonacci">Fibonacci esimerkki</a></li>
  </ul>

  <h3 id="chapter-1-historia">Historia</h3>

  <p>Pythonin historia alkaa 1980-luvulta. Ensimmäinen versio
  ohjelmointikielestä kehitettiin 80-luvun loppupuolella Guido van
  Rossumin toimesta. Python kehitettiin ABC kielen seuraajaksi,
  joka kykenee mm. poikkeusten käsittelyyn ja yhteistyöhön Amoeba
  -käyttöjärjestelmän kanssa. Kielen alun perin kehittänyt van
  Rossum on edelleen aktiivisesti mukana kielen kehittämisessä</p>

  <p>Python 2.0, julkaistiin 16. lokakuuta 2000. Toinen versio
  sisälsi useita uusia ominaisuuksia, mukaan lukien täydellisen
  roskienkeruumekanismin ja Unicode-tuen. Muutos tapahtui myös
  kielen kehitysprosessissa. Python -yhteisölle annettiin vapaammat
  kädet osallistua mukaan kielen kehitykseen.</p>

  <p>Joulukuussa 2008 ilmestyi 3.0, jolla haluttiin korjata
  havaittuja ongelmia kielessä. Kielestä haluttiin poistaa
  duplikaatteja ominaisuuksia poistamalla vanhat tavat tehdä
  asioita. 3.x ei ole taaksepäin yhteensopiva versioiden 2.x ja
  vanhempien kanssa. Vanhoille versioille kirjoitetut ohjelmat
  eivät toimi suoraan versiossa 3.0. Siirtymän helpottamiseksi on
  toteutettu käännösohjelma (2to3), joka kääntää automaattisesti
  osan koodista kielen uudempaan versioon. Lisäksi useita
  kolmosversion keskeisiä ominaisuuksia on toteutettu rinnakkain
  kehitettyyn 2.6 versioon, mikä mahdollistaa niiden hyödyntämisen
  ilman uudempaan syntaksiin siirtymistä. [<a href=
  "#ref-history-of-python">3</a>]</p>

  <h3 id="chapter-1-perustietoa">Python perustietoa</h3>

  <ul>
    <li>Keskeinen suunnittelufilosofia: selkeä, luettava
    syntaksi</li>

    <li>Tulkattava</li>

    <li>Oliosuuntautunut ohjelmointikieli</li>

    <li>Korkean tason dynaamiset datatyypit</li>

    <li>Kattavat standardikirjastot ja saatavilla paljon kolmansien
    osapuolien moduuleja eri tarkoituksiin</li>

    <li>Poikkeuksiin <i>(exception)</i> pohjautuva virheiden
    hallinta</li>

    <li>Tukee useita ohjelmointiparadigmoja <i>(esim.
    oliopohjainen, proseduraalinen, funktionaalinen)</i></li>

    <li>Toimii useilla eri alustoilla, esim.

      <ul>
        <li>Windows</li>

        <li>Mac</li>

        <li>Linux</li>

        <li>Amiga</li>

        <li>Nokia series 60</li>
      </ul>
    </li>

    <li>Avoin lähdekoodi, vapaasti käytettävissä ja jaettavissa
    (myös kaupalliseen käyttöön)</li>

    <li>Upotettavissa sovelluksiin skriptausrajapintana <i>(esim.
    Blender)</i></li>

    <li>Python nimi tulee tv-sarjasta <i>Monty Python's Flying
    Circus</i>.</li>
  </ul>

  <p>Pythonista on tällä hetkellä olemassa kaksi vakaata haaraa.
  2.x -haara saa tällä hetkellä pelkkiä virheitä korjaavia
  päivityksiä. Uudet ominaisuudet kehitetään vain 3.x -haaralle.
  Suurempi osa kolmansien osapuolien ohjelmistoista käyttää vielä
  Ptyhonin 2.x -versiota.</p>

  <p>Yleisin Pythonin toteutus on CPython, joka on kirjoitettu
  C-kielellä. CPython kääntää Python ohjelmat. Se kääntää Python
  ohjelmat tavukoodiksi, joka suoritetaan virtuaalikoneessa.
  CPython on saatavilla useille eri käyttöjärjestelmille ja sen
  mukana tulee laaja peruskirjasto.</p>

  <p>Muita Python toteutuksia on esimerkiksi Jython, IronPython ja
  PyPy.</p>

  <h3 id="chapter-1-kayttokohteet">Käyttökohteet</h3>

  <p>Yksi suosittu tapa hyödyntää Pythonia on sen käyttäminen
  skriptikielenä erilaisissa sovelluksissa. Pythonia käyttävät
  skriptikielenä esimerkiksi 3d-mallinnusohjelmistot Maya ja
  Blender, kuvankäsittelyohjelma GIMP ja se on toinen valittavissa
  oleva skriptikieli Google Docsissa</p>

  <p>Erilaisten kirjastojen <i>(NumPy, SciPy, Matplotlib, ...)</i>
  avulla Pythonia voidaan käyttää tehokkasti tieteelliseen
  laskentaan.</p>

  <p>Monissa käyttöjärjestelmissä Python kuuluu
  peruskomponentteihin. Python löytyy muunmuassa useimmista Linux
  distribuutioista, OpenBSD:stä, ja Mac OS X:stä.</p>

  <h3 id="chapter-1-fibonacci">Fibonacci esimerkki</h3>

  <p>Seuraavassa esimerkki ohjelmasta, joka lukee yhden
  syöttöluvun, laskee ensimmäisen Fibonaccin luvun, joka on
  syöttölukua suurempi ja lopuksi tulostaa kyseisen Fibonaccin
  luvun.</p>
  <pre>
import sys

def fib(n):
    """Palauttaa ensimmäisen Fibonaccin luvun, joka on syöttölukua suurempi."""
    a, b = 0, 1
    while b &lt;= n:
        a, b = b, a+b
    return b

if __name__ == "__main__": # Pääohjelma
    s = input("Anna fibonacci syöttöluku: ") # Lue syöte käyttäjältä

    # input palauttaa aina stringin, mutta haluamme kokonaisluvun
    try:
        # Yritä muuttaa syöte kokonaislukutyypiksi
        n = int(s)
    except ValueError:
        # Tyypin muutos epäonnistui, poistu ohjelmasta virheviestillä
        sys.exit("Antamasi syöte ei ollut kokonaisluku!")

    print(fib(n))
</pre>

  <p>Ensimmäisen rivin <code>import sys</code> lause importtaa eli
  tuo fibonacci-moduulin sys-moduulin käytettäväksi. sys-moduulin
  exit-metodia käytetään ohjelman loppupuolella päättämään ohjelman
  suoritus sopivalla virheviestillä, jos käyttäjän antama syöte ei
  ollut kokonaisluku.</p>

  <p>Varsinainen Fibonacci luvun laskeminen tapahtuu
  fib-funktiossa. fib-funktio asettaa ensiksi muuttujille a ja b
  Fibonaccin lukujonon alkuarvot <code>a = 0</code> ja <code>b =
  1</code>. Lukujonon lukuja lasketaan while-silmukassa, kunnes
  viimeisin laskettu Fibonaccin luku <code>b = a+b</code> on
  syöttölukua suurempi. Lopuksi palautamme halutun luvun.</p>

  <p>Koska Python ohjelmissa ei ole varsinaista
  "pääohjelmafunktiota", niin se yleensä merkitään näkyviin
  <code>if __name__ == "__main__":</code> lauseella. Tämä suorittaa
  pääohjelma-alueen vain kun moduuli suoritetaan pääohjelmana eikä
  importattuna jostain toisesta moduulista.</p>

  <p>Käyttäjän syöte luetaan input-funktiolla. fib-funktiota varten
  halutaan kokonaislukusyöte. Syötteen tyyppi on riippuvainen
  käyttäjästä, joten se muutetaan kokonaisluvuksi ennen
  fib-funktion kutsua <code>int(x)</code>-kutsulla.
  Kokonaislukumuutos voi kuitenkin epäonnistua, jolloin
  <code>int(x)</code> nostaa <code>ValueError</code> poikkeuksen.
  Jotta käyttäjälle saadaan annettua sopiva virheviesti, niin
  käsittelemme poikkeuksen try-except-rakenteen avulla. Pääohjelman
  lopuksi kutsumme fib-funktiota syötteellä ja tulostamme sen
  palautusarvon.</p>

  <h2 id="chapter-2">2. Alkiorakenne – millaisista palikoista ohjelmat
  rakennetaan</h2>

  <ul>
    <li><a href="#chapter-2-tunnukset">Tunnukset</a></li>
    <li><a href="#chapter-2-varatut-sanat">Varatut sanat, avainsanat</a></li>
    <li><a href="#chapter-2-literaalivakiot">Literaalivakiot</a></li>
    <li><a href="#chapter-2-erottimet-yms">Erottimet, sisennykset,
    rivinvaihdot</a></li>
    <li><a href="#chapter-2-edut-ja-haitat">Arvio kieleen valittujen
    ratkaisujen eduista ja haitoista</a></li>
  </ul>

  <h3 id="chapter-2-tunnukset">Tunnukset</h3>

  <p>Python 3:ssa tunnukset voidaan nimetä käyttäen merkkejä a-z,
  A-Z, 0-9 ja _. Tunnus ei kuitenkaan voi alkaa numerolla. Pienet
  ja iso kirjaimet tulkitaan eri kirjaimiksi. Tunnukset voivat olla
  rajoittamattoman pituisia. Lisäksi Python 3 tukee joitakin
  ASCII-järjestelmän ulkpuolisia unicode-merkkejä. Tarkempi listaus
  tuetuista merkeistä löytyy osoitteesta: <a href=
  "http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html">http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html</a>.
  Merkit on jaoteltu kahteen osaan: ID_Start ja ID_Continue,
  excluding ID_Start. Näiden merkkijoukkojen yhdiste sisältää
  kaikki unicode-merkit joita voi esiintyä python-tunnuksen
  nimessä, siten että tunnuksen nimi voi alkaa vain ensimmäisen
  joukon merkillä. <a href="#ref-tunnukset-py3-spec">[2]</a></p>

  <p>Seuraavassa lyhyt esimerkki joka demonstroi erikoisempien
  merkkien käyttöä Python 3 ohjelmassa:</p>
  <pre>
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

def python_3_tukee_unicodemerkkejä_varsin_laajasti(ភាសាខ្មែរ="khemrin kieli khmeriksi"):
    print("Hei vaan ja hellurei!", ភាសាខ្មែរ)

    epävalidia_python_koodia='kuitenkin_esim_€_merkki_ei_ole_sallittu = "epic fai"'
    try:
        exec(epävalidia_python_koodia)
    except SyntaxError as se:
        print("€-merkki ei ollut sallittu muuttujan nimessä :'(", se)

    validia_python_koodia = epävalidia_python_koodia.replace("€", "e")
    exec(validia_python_koodia)
    print("Hyvin pyyhkii. No problemo, kun €-merkit vaihdettiin e-kirjaimiksi")

if __name__ == "__main__":
    python_3_tukee_unicodemerkkejä_varsin_laajasti()

</pre>

  <p>Yllä oleva python ohjelma tulostaa konsoliin tekstin:</p>
  <pre>
Hei vaan ja hellurei! khemrin kieli khmeriksi
€-merkki ei ollut sallittu muuttujan nimessä :'( invalid character in identifier (&lt;string&gt;, line 1)
Hyvin pyyhkii. No problemo, kun €-merkit vaihdettiin e-kirjaimiksi

</pre>

  <p><a href="esimerkit/unicode_sample.py">Lataa esimerkki
  tästä</a></p>

  <h3 id="chapter-2-varatut-sanat">Varatut sanat</h3>

  <p>Seuraavassa listattuna (Pyton 3.0.1:n mukainen, tässä on
  pieniä eroavaisuuksia 2.x -sarjan kanssa) varatut sanat <a href=
  "#ref-varatut-sanat-py3-spec">[1]</a> sen tarkemmin niitä
  esittelemättä.</p>
  <pre>
False      class      finally    is         return
None       continue   for        lambda     try
True       def        from       nonlocal   while
and        del        global     not        with
as         elif       if         or         yield
assert     else       import     pass
break      except     in         raise


</pre>

  <h3 id="chapter-2-literaalivakiot">Literaalivakiot</h3>

  <p>Python tukee seuraavia literaalivakioita [<a href=
  "#ref-literaalivakiot">4</a>]:</p>

  <ul>
    <li>merkkijonot,<br>
    <code>"hello"</code>, <code>'world'</code>,<br>
    <code>"""Olen<br>
    monella<br>
    rivillä"""</code></li>

    <li>kokonaisluvut,<br>
    <code>7</code>, <code>79228162514264337593543950336</code>,
    <code>0b100110111</code>, <code>0xdeadbeef</code></li>

    <li>liukuluvut,<br>
    <code>3.14</code>, <code>10.</code>, <code>.001</code>,
    <code>1e100</code>, <code>3.14e-10</code>,
    <code>0e0</code></li>

    <li>imaginääriluvut<br>
    <code>3.14j</code>, <code>10.j</code>, <code>10j</code>,
    <code>.001j</code>, <code>1e100j</code>,
    <code>3.14e-10j</code></li>
  </ul>

  <p>Numeerisista literaaleista on hyvä mainita vielä se, että ne
  eivät sisällä etumerkkiä. Esimerkiksi merkintä <code>-1</code>
  koostuu yksipaikkaisesta operaatiosta <code>-</code> ja
  literaalista <code>1</code>.</p>

  <h3 id="chapter-2-erottimet-yms">Erottimet, sisennykset, rivinvaihdot</h3>

  <p>Pythonissa käytetään sisennyksiä rajaamaan lohkoja. Sisennystä
  kasvatetaan tiettyjen lausekkeiden jälkeen ja vastaavasti
  sisennystä pienennetään lohkon päättymisen merkiksi. Sekä tabit
  että välilyönnit kelpaavat sisennysmerkeiksi pythonissa.</p>

  <p>Sisennyksen määrällä ei ole väliä, sisennys voi olla yhden
  tabin tai vaikkapa kuuden välilyönnin pituinen <i>(<b>huom!</b>
  tabien ja välilyöntien sekaisin käyttäminen ei ole sallittua
  Pythonissa)</i>. Ainoastaan suhteellisella sisennyksen määrällä
  on väliä sisäkkäisissä lohkoissa.</p>

  <p>Lauseet erotellaan toisistaan rivinvaihdoilla. Useita lauseita
  voidaan kirjoittaa samalle riville käyttämällä puolipistettä.
  Kontrollirakenteissa totuusarvolausekkeita seuraa aina
  kaksoispiste ja lausekkeessa ei ole pakko käyttää sulkuja.</p>

  <p>Alla olevissa esimerkeissä kaikki kolme if-lausetta tekevät
  saman asian <i>(tulostavat sanat "spam" ja "ham")</i>:</p>
  <pre>
if 1 == 1:
    print "spam"
    print "ham"

</pre>
  <pre>
if 1 == 1:
    print "spam"; print "ham"

</pre>
  <pre>
if 1 == 1: print "spam"; print "ham"

</pre>

  <h3 id="chapter-2-edut-ja-haitat">Arvio kieleen valittujen ratkaisujen
  eduista ja haitoista</h3>

  <p>Unicode-tuki python 3:ssa tekee aidosti mahdolliseksi
  ohjelmoinnin ohjelmoijan omalla äidinkielellä. Tämä on varmasti
  monessa mielessä hyvä asia ja sen hyödyntäminen todennäköisesti
  parantaa koodin luettavuutta kehittäjäyhteisössä. Toisaalta tällä
  alalla ei ole ollenkaan tavatonta, että ohjelmaa kehitetään
  ympäri maailmaa ja kehittäjien äidinkielet vaihtelevat suuresti.
  Tällöin on käytettävä jotakin yhteistä kieltä eli siis yleensä
  englantia ja tämä unicode-tuki ei juurikaan auta. Toinen tilanne
  jolloin koodia ei varmaankaan haluta tehdä äidinkielellä on, jos
  tuotetaan avoimen lähdekoodin ratkaisuja. Muutoin saatetaan
  varsin tehokkaasti eliminoida iso osa käyttäjäyhteisön
  potentiaalista jatkokehittää tuotetta. Yleisestiottaen tuote joka
  on ohjelmoitu vaikkapa suomeksi rajoittaa
  jatkokehitysmahdollisuuksia vaikka alkuperäisen kehitystyön
  kannalta kielivalinnalla olisikin ollut positiivisia vaikutuksia.
  Kustannussyistä jatkokehitys saatettaisiin joissain tilanteissa
  haluta tuottaa jossakin edullisemmassa maassa, mutta tämä ei nyt
  olekaan mahdollista ilman huomattavaa käännöstyötä. Kun lisäksi
  otetaan huomioon, että unicode-tuen sisällyttäminen tunnuksiin
  monimutkaistaa kielen implementaatioiden toteuttamista, niin olen
  kyllä henkilökohtaisesti hieman skeptinen koko ominaisuuden
  järkevyydestä. En kyllä itse ainakaan ikinä ohjelmoisi
  vakavissani mitään millään muulla kielellä kuin englannilla.</p>

  <p>Pythonissa sisennystapa ei ole ohjelmoijan täysin vapaasti
  valittavissa, vaan ohjelmoinnissa pakotetaan käyttämään
  tietynlaista sisennystyyliä. Etu tästä on, että ohjelmoija ei voi
  vahingossa kirjoittaa sekavasti sisennettyä koodia, koska se
  rikkoo ohjelman suorituksen. Virheiden mahdollisuus pienenee, kun
  ohjelma tekee, mitä se näyttääkin tekevän, kun virheellinen
  sisentäminen ei pääse sekoittamaan lukijaa. Python koodin
  luettavuutta parantaa se, että kaikki joutuvat käyttämään
  yhtenäistä sisennystapaa.</p>

  <h2 id="chapter-3">3. Tunnusten näkyvyysalueet</h2>
  <!-- TODO: parempi ryhmittely ja otsikkojen nimet -->
  
  <ul>
    <li><a href="#chapter-3-lohkorakenne">Lohkorakenne</a></li>
    <li><a href="#chapter-3-sidonta">Sidonta</a></li>
    <li><a href="#chapter-3-sisakkaiset-nimiavaruudet-ja-funktiot">Sisäkkäiset nimiavaruudet ja funktiot</a></li>
    <li><a href="#chapter-3-1-2-ja-3-luokan-arvo">Ensimmäisen, toisen ja kolmannen luokan arvo</a></li>
    <li><a href="#chapter-3-edut-ja-haitat">Arvio kieleen valittujen ratkaisujen eduista ja haitoista</a></li>
  </ul>
  
  <h3 id="chapter-3-lohkorakenne">Lohkorakenne</h3>
  <p>Pythonissa lohkoksi kutsutaan koodinpätkää, joka suoritetaan yhtenä
  yksikkönä. Seuraavia rakenteita kutsutaan lohkoiksi:
    <ul>
      <li>moduuli</li>
      <li>funktion vartalo</li>
      <li>luokan määrittely</li>
      <li>jokainen interaktiivisesti kirjoitettu komento</li>
      <li>skriptitiedosto (annettuna tulkille komentoriviparametrina)</li>
      <li>skriptikomento (annettuna tulkille -c komentoriviparametrin arvona)</li>
      <li>exec() tai eval() -funktioille merkkijonona annettu koodi</li>
    </ul>
  [<a href="#ref-nimet-ja_sidonta-py3-spec">6</a>]
  </p>
  <p>Jos lohkon sisällä määritellään lokaali muuttuja, on tämän muuttujan näkyvyysalue
  (scope) rajoitettu siihen lohkoon. Mikäli tunnus määritellään funktion vartalossa, niin
  näkyy se myös funktion vartalon sisäisille lohkoille (ellevät nämä sido tunnukselle
  uutta merkitystä). Moduulitason tunnukset ovat globaaleja. Mikäli lohkon sisältä halutaan
  (eksplisiittisesti) viitata lohkon ulkopuolisiin muuttujiin, niin voidaan käyttää varattuja
  sanoja nonlocal ja global. Määreellä nonlocal vihjataan, että halutaan viitata
  näkyvyysaluehierakriassa seuraavaan tasoon jolta tunnus löytyy. Vastaavasti global-määreellä
  siirrytään suoraan etsimään tunnusta globaalilta näkyvyysalueelta.</p>

  <h3 id="chapter-3-sidonta">Sidonta</h3>
  <p>Pythonissa sidonta tapahtuu osittain dynaamisesit ja osittain staattisesti.
  Käytännössä siis näkyvyysalueet (scope) määritellään staattisesi, mutta niitä
  käytetään dynaamisesti. Eli toisin sanoen eri näkyvyysalueilla olevat tunnukset
  määritellään, mutta niihin ei liitetä arvoa. Ajonaikaisesti voidaan määritellä
  uusia tunnuksia globaalille tasolle. On kuitenkin huomioitava, että Python-funktioille
  ei vo määritellä uusia lokaaleja tunnuksia funktion parsimisen jälkeen. Pythoninsa
  dokumentaatioissa myös vihjataan, että staattisuus staattisuutta tullaan jatkossa
  lisäämään.
  <!--TODO: Timo tarkistapa nämä nyt vielä jostain http://bugs.python.org/issue10043
  Lähde: http://docs.python.org/py3k/tutorial/classes.html#python-scopes-and-namespaces -->
  </p>

  <h3>Esimerkki tunnusten näkyvyydestä, lohkorakenteista ja sidonnasta</h3>
  <p>Seuraava esimerkki pyrkii demonstroimaan hieman kaikkea tunnusten
  näkyvyyteen liittyvää. Siinä näytetään miten saadaan aikaan ajonaikainen
  poikkeus sidonnasta ja toisaalta myös demonstroidaan muuttujien näkyvyyttä.</p>
  <pre>
#!/usr/bin/python3.1
# -*- coding: UTF-8 -*-

muuttuja="globaali"
print("moduulitasolla", muuttuja)

def main():
    import sys
    #muuttuja on selvästi edelleen globaalien nimien joukossa
    if 'muuttuja' in globals(): print("muuttuja on määritelty globaalilla tasolla")

    try:
        #FAIL! UnboundLocalError: local variable 'muuttuja' referenced before assignmen!
        print("fail", muuttuja)
    except UnboundLocalError:
        name, msg = sys.exc_info()[:2]

    #Btw. alemmalla lohkotasolla määritellyt muuttujat näkyvät ylemmälle
    print(name.__name__+":", msg)

    #Ja syy on seuraavalla koodirivillä. Näin käy sillä kääntäjä merkitsee seuraavan
    #lauseen takia nimen muuttuja olemaan tyypiltään lokaali viittaus tässä
    #lohkossa. Siten suoritusaikana kun nimeen muuttuja viitataan yllä, sitä
    #etsitäänkin vain lokaalien muuttujien joukosta. Koska tämä lause jossa lokaali
    #nimi muuttuja sidotaan merkkijonoon "lokaali", on ensimmäisen nimeen tehdyn
    #viittauksen jälkeen tässä lohkossa, on muuttuja tässä siis vielä
    #sitomatta.
    muuttuja = "lokaali"
    print("main", muuttuja)

    def fun():
        global muuttuja
        print("funktio", muuttuja)
    fun()

    lam = lambda: print("lambda", muuttuja)
    lam()

    #Seuraava if-lause saisi kuitenkin aikaan sen, että kaikkialla main-metodissa
    #tunnus muuttuja viittaisi saman nimiseen moduulitason globaaliin muuttujaan.
    #Tämä ei toki sinänsä liene kovin yllättävää, mutta toimii kuitenkin pienenä
    #demonstraatio siitä, että if-lause ei ole lohko. Ei ainakaan Pythonissa :)
    #if True:
    #    global muuttuja
    #    print("globaali", muuttuja)

if __name__ == '__main__':
    main()
    print("moduulitasolla if-lohkossa", muuttuja)
  </pre>

<p>Skripti tekee seuraavan tulostuksen (<a href="esimerkit/unbound_excep_esim.py">lataa esimerkki</a>)</p>
  <pre>
moduulitasolla globaali
muuttuja on määritelty globaalilla tasolla
UnboundLocalError: local variable 'muuttuja' referenced before assignment
main lokaali
funktio globaali
lambda lokaali
moduulitasolla if-lohkossa globaali
  </pre>

  <h3 id="chapter-3-sisakkaiset-nimiavaruudet-ja-funktiot">Sisäkkäiset nimiavaruudet ja funktiot</h3>

  <p>Python tukee sisäkkäisiä nimiavaruuksia versiosta 2.2 lähtien
  [<a href="#ref-sulkeumat-py22">5</a>]. Sitä ennen nimiavaruuksia
  oli vain kolme: paikallinen nimiavaruus, moduulitason nimiavaruus
  ja sisäänrakennettu nimiavaruus. Vaikka funktion määrittely oli
  mahdollista toisen funktion sisällä, niin sisäkkäinen funktio ei
  voinut viitata oman nimiavaruutensa ulkopuolisiin nimiin.</p>
  <pre>
def eka(p):
    x = "olen ekan x"
    print("--- eka alkaa ---")
    p() # tokan paikalliset eivät näy tänne.
        # funktio p käydään suorittamassa määrittelykohdan ympäristössä
    print(x)
    print("--- eka päättyy ---")

def toka():
    print("--- toka alkaa ---")
    x = "olen tokan x"

    def fpar():
        nonlocal x # muuttuja x viittaa nyt sulkeuman ulkopuoliseen viimeiseksi
                   # sidottuun tunnukseen eli tokan muuttujaan x
        print(x)
        x = "tokan x on muutettu!"

    eka(fpar) # "nimetyn sulkeuman" välitys funktioparametrina
    print(x) # viittaus paikalliseen tunnukseen
    print("--- toka päättyy ---")

if __name__ == "__main__": # Pääohjelma
    toka()
</pre>

  <p>Ohjelma tulostaa:</p>
  <pre>
--- toka alkaa ---
--- eka alkaa ---
olen tokan x
olen ekan x
--- eka päättyy ---
tokan x on muutettu!
--- toka päättyy ---
</pre>

  <p>Python tukee myös anonyymejä funktioita lambda-lausekkeiden
  muodossa. Lambda-lausekkeella voi helposti luoda pieniä
  anonyymejä funktioita. Esimerkiksi funktio <code>lambda: a, b:
  a*b</code> palauttaa kahden argumenttinsa kertolaskun.
  Lambda-lauseke on kuitenkin aina vain yksi lauseke eikä lause,
  joten siihen ei voi sisällyttää esimerkiksi toisto- tai
  ehtolauseita suoraan. Se ei siis vastaa useimpien muiden kielten
  anonyymejä funktioita. Lambda-lausekkeet voivat viitata
  nimiavaruutensa ulkopuolisiin tunnuksiin kuten funktiot:</p>
  <pre>
def tee_kertoja(n):
    return lambda x: x * n

f = tee_kertoja(5)
print(f(3)) # 15
print(f(5)) # 25
</pre>

  <h3 id="chapter-3-1-2-ja-3-luokan-arvo">Ensimmäisen, toisen ja kolmannen luokan arvo</h3>
  
  <p>Pythonissa yksi tavotteista on ollut tehdä kaikista objekteista ensimmäisen luokan arvoja, eli sellaisia, joita voidaan:</p>
  <ul>
    <li>sijoittaa muuttujaan</li> 
    <li>välittää parametrina</li>
    <li>palauttaa funktion arvona</li>
  </ul>

  <p>Huomion arvoista on, että Pythonissa myös metodit ovat ensimmäisen luokan arvoja. [<a href="#ref-ensimmaisenluokan">7</a>]</p>

  <h3 id="chapter-3-edut-ja-haitat">Arvio kieleen valittujen ratkaisujen eduista ja haitoista</h3>

  <h2>Lähteet</h2>

  <ol>
    <li id="ref-varatut-sanat-py3-spec"><a href=
    "http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#keywords">
    http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#keywords</a></li>

    <li id="ref-tunnukset-py3-spec"><a href=
    "http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#identifiers-and-keywords">
    http://docs.python.org/release/3.0.1/reference/lexical_analysis.html#identifiers-and-keywords</a></li>

    <li id="ref-history-of-python"><a href=
    "http://en.wikipedia.org/wiki/History_of_Python">http://en.wikipedia.org/wiki/History_of_Python</a></li>

    <li id="ref-literaalivakiot"><a href=
    "http://docs.python.org/py3k/reference/lexical_analysis.html#literals">
    http://docs.python.org/py3k/reference/lexical_analysis.html#literals</a></li>

    <li id="ref-sulkeumat-py22"><a href=
    "http://docs.python.org/release/2.2.3/whatsnew/node9.html">http://docs.python.org/release/2.2.3/whatsnew/node9.html</a></li>

    <li id="ref-nimet-ja_sidonta-py3-spec"><a href=
    "http://docs.python.org/py3k/reference/executionmodel.html#naming-and-binding">
    http://docs.python.org/py3k/reference/executionmodel.html#naming-and-binding</a></li>
    
    <li id="ref-ensimmaisenluokan"><a href=
    "http://python-history.blogspot.com/2009/02/first-class-everything.html">http://python-history.blogspot.com/2009/02/first-class-everything.html</a></li>
  </ol>
</body>
</html>
